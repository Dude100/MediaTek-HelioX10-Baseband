/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 * Filename:
 * ---------
 * nvram_ltable.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This is
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*
 * include
 */
#include "stdio.h"
#include "string.h"

#include "kal_general_types.h"
#include "kal_public_api.h"

#if defined(__MMI_FMI__)
#if !defined(NVRAM_NOT_PRESENT) && !defined(__L1_STANDALONE__)
#include "custom_jump_tbl.h"
#include "resource_custpack_jtbl.h"
#endif /* !defined(NVRAM_NOT_PRESENT) && !defined(__L1_STANDALONE__) */
#include "resource_verno.h"
#endif

#include "nvram_editor_data_item.h"
#include "nvram_main.h"

#include "nvram_lid_statistics.h"

#ifdef __NVRAM_OTP__
#include "fs_gprot.h"
#include "fs_iprot.h"
#endif



#include "custom_nvram_cat.h"

/********************************************
 * External API, cannot include header file
 **************************************************/
extern kal_char *release_verno(void);
extern kal_char *release_branch(void);
extern kal_char *release_flavor(void);
extern kal_bool nvram_custom_lock_status(void);


/********************************************
 * Global and Static Variable
 **************************************************/
typedef struct
{
    kal_uint8 const* version;
    nvram_lid_enum lid[NVRAM_CUSTPACK_TOTAL];
}nvram_custpack_lid_tbl_struct;


//#if !defined(NVRAM_NOT_PRESENT) && !defined(__L1_STANDALONE__)
#ifdef __NVRAM_SUPPORT_CUSTPACK__
static custpack_nvram_header *custpack_nvram_header_ptr;
#endif
//#endif

#ifdef __NVRAM_OTP__
typedef struct
{
    nvram_lid_enum  LID;                /* Logical Data Item ID */
    kal_uint32  offset;                 /* start address in Shadow buffer*/
}nvram_otp_table_sturct;

static nvram_otp_table_sturct nvram_otp_ltable[NVRAM_OTP_TOTAL];
#endif

#ifndef __MTK_TARGET__
#ifdef _MSC_VER
nvram_ltable_entry_struct __pragma(data_seg("_nvram_ltable_begin")) _nvram_ltable_start ={0};
#else
__attribute__ ((section("_nvram_ltable_begin"))) nvram_ltable_entry_struct _nvram_ltable_start ={0};
#endif
#endif

static void nvram_assign_sys_default(nvram_lid_enum file_id, kal_uint8 *buffer, kal_uint16 buffer_size);

ltable_entry_struct logical_data_item_table_internal[] =
{
    {
        NVRAM_EF_SYS_LID,
        NVRAM_EF_SYS_TOTAL,
        NVRAM_EF_SYS_SIZE,
        NVRAM_DEFAULT_FUNC(nvram_assign_sys_default),
        NVRAM_CATEGORY_INTERNAL | NVRAM_CATEGORY_FUNC_DEFAULT,
        NVRAM_ATTR_WRITEPROTECT | NVRAM_ATTR_MULTIPLE,
        "MT00",
        VER(NVRAM_EF_SYS_LID)
    },
#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif    
#ifdef __NVRAM_SUPPORT_CUSTPACK__
    {
        NVRAM_EF_CUSTPACK_VERNO_LID,
        NVRAM_EF_CUSTPACK_VERNO_TOTAL,
        NVRAM_EF_CUSTPACK_VERNO_SIZE,
        NVRAM_NORMAL(NVRAM_EF_ZERO_DEFAULT),
        NVRAM_CATEGORY_INTERNAL,
        NVRAM_ATTR_MULTIPLE | NVRAM_ATTR_WRITEPROTECT,
        "MT02",
        VER(NVRAM_EF_CUSTPACK_VERNO_LID)
    },
#endif
#ifdef __SECURE_RO_ENABLE__        
    {
        NVRAM_EF_SECUPACK_VERNO_LID,
        NVRAM_EF_SECUPACK_VERNO_TOTAL,
        NVRAM_EF_SECUPACK_VERNO_SIZE,
        NVRAM_NORMAL(NVRAM_EF_ZERO_DEFAULT),
        NVRAM_CATEGORY_INTERNAL,
        NVRAM_ATTR_MULTIPLE | NVRAM_ATTR_WRITEPROTECT,
        "MT02",
        VER(NVRAM_EF_SECUPACK_VERNO_LID)
    },
#endif    
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif    
#ifdef __NVRAM_UNIT_TEST__
    {
        NVRAM_EF_NVRAM_UNIT_TEST_LID,
        NVRAM_EF_NVRAM_UNIT_TEST_TOTAL,
        NVRAM_EF_NVRAM_UNIT_TEST_SIZE,
        NVRAM_NORMAL((const kal_uint8 *)NVRAM_EF_ZERO_DEFAULT),
#ifdef __SECURE_DATA_STORAGE__
        NVRAM_CATEGORY_INTERNAL,
#else
        NVRAM_CATEGORY_USER,
#endif
        NVRAM_ATTR_AVERAGE,
        "NV00",
        VER(NVRAM_EF_NVRAM_UNIT_TEST_LID)
    },
#endif
};

#ifndef __MTK_TARGET__
#ifdef _MSC_VER
#pragma comment(linker, "/MERGE:_nvram_ltable_content=_nvram_ltable_begin")

nvram_ltable_entry_struct __pragma(data_seg("_nvram_ltable_end")) the_nvram_ltable_end = {0};

#pragma comment(linker, "/MERGE:_nvram_ltable_end=_nvram_ltable_begin")

nvram_ltable_entry_struct __pragma(data_seg("thegarbge")) the_garbge = {0};
#else
  // section merge is moved to linker script for other compilers
  __attribute__ ((section("_nvram_ltable_end"))) nvram_ltable_entry_struct the_nvram_ltable_end = {0};
  __attribute__ ((section("thegarbge"))) nvram_ltable_entry_struct the_garbge = {0};
#endif
//#ifndef __L1_STANDALONE__
#ifdef __NVRAM_SUPPORT_CUSTPACK__
#pragma comment(linker, "/INCLUDE:_g_nvram_custpack_init")
#endif
//#endif

#include "nvram_ltable_list.h"
#endif

nvram_ltable_entry_struct *logical_data_item_table;

extern void nvram_ltable_register(nvram_ltable_entry_struct *table);
extern nvram_ltable_entry_struct logical_data_item_table_factory[];
extern nvram_ltable_entry_struct logical_data_item_table_core[];
extern nvram_ltable_entry_struct logical_data_item_table_exception[];

/*****************************************************************************
 * FUNCTION
 *  nvram_pre_init
 * DESCRIPTION
 *  This function init necessary NVRAM information.
 *  (no matter NVRAM task is on or not)
 * PARAMETERS
 *  void
 * RETURNS
 *  NVRAM_ERRNO_SUCCESS if succeed, NVRAM_ERRNO_INVALID otherwise (ie, invalid LID).(?)(?)
 *****************************************************************************/
void nvram_pre_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    //NVRAM table force link
    nvram_ltable_register(logical_data_item_table_internal);
    nvram_ltable_register(logical_data_item_table_factory);
    nvram_ltable_register(logical_data_item_table_core);
    nvram_ltable_register(logical_data_item_table_exception);

    if (nvram_ptr->ltable.table == NULL)    /* assume that ltable still not initialized if total_LID==0 */
    {
        nvram_init_secupack(nvram_ptr->secret_key);

        custom_nvram_get_key((char*)nvram_ptr->secret_key, nvram_ptr->secret_key);

        /* Construct logical data item table */
        nvram_ltable_construct();
    }
}
//#ifndef __L1_STANDALONE__
#ifdef __NVRAM_SUPPORT_CUSTPACK__
void nvram_custpack_int_init(custpack_nvram_header *custpack_ptr)
{
    custpack_nvram_header_ptr = custpack_ptr;
}
#endif
//#endif
/*****************************************************************************
 * FUNCTION
 *  nvram_assign_custpack_default_value
 * DESCRIPTION
 *  This function is assign
 *      the point of default value from 3rd jump table to logical table
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#define NVRAM_LTABLE_C_ONLY
static void nvram_assign_sys_default(nvram_lid_enum file_id, kal_uint8 *buffer, kal_uint16 buffer_size)
{

    switch(file_id)
    {
        case NVRAM_EF_SYS_LID:
            memcpy(buffer, nvram_ptr->coded_version, buffer_size);
            break;
        case NVRAM_EF_BRANCH_VERNO_LID:
            memcpy(buffer, nvram_ptr->branch_version, buffer_size);
            break;
        case NVRAM_EF_FLAVOR_VERNO_LID:
            memcpy(buffer, nvram_ptr->flavor_version, buffer_size);
            break;
    }
}
static void nvram_assign_custpack_default_value(void)
{
#if defined(__MMI_FMI__)
#if !defined(NVRAM_NOT_PRESENT) && !defined(__L1_STANDALONE__)

#ifdef __NVRAM_SUPPORT_CUSTPACK__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 file_idx;
    nvram_lid_enum custpack_idx = 0;
    nvram_ltable_entry_struct *ldi = &logical_data_item_table[0];
    #include "nvram_custpack_table_lid.c"

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

//    custpack_header = (void **)GET_ResCUSTPACK_Addr(g_entry_preamble);
//    custpack_nvram_header_ptr = (custpack_nvram_header*) custpack_header[g_custpack_nvram];

#ifndef __MTK_TARGET__ 
    extern void nvram_custpack_init(void);
    nvram_custpack_init();

#endif
    do
    {

//    #ifdef __NVRAM_SUPPORT_CUSTPACK__
        if (ldi->LID == NVRAM_EF_CUSTPACK_VERNO_LID)
        {
            memset(nvram_ptr->custpack_version, 0, NVRAM_EF_CUSTPACK_VERNO_SIZE + 1);

            if (custpack_nvram_header_ptr->version != NULL)
            {
                strncpy((char*)nvram_ptr->custpack_version, (char*)custpack_nvram_header_ptr->version, NVRAM_EF_CUSTPACK_VERNO_SIZE);
            }
            else
            {
                sprintf((char*)nvram_ptr->custpack_version, "version %d", CURRENT_CUSTPACK_RES_VERSION);
            }

            ldi->default_value = nvram_ptr->custpack_version;
        }
//    #endif

        if (!NVRAM_IS_CATEGORY_CUSTPACK(ldi->category))
        {
            continue;
        }

        for (file_idx = 0; file_idx < NVRAM_CUSTPACK_TOTAL; file_idx++)
        {
            if (custpack_nvram_lid_tbl.lid[file_idx] == ldi->LID)
            {
                break;
            }
        }
        
        ldi->default_value = custpack_nvram_header_ptr->custpack_default[file_idx];
        custpack_idx++;

//        EXT_ASSERT(custpack_idx <= NVRAM_CUSTPACK_TOTAL && file_idx <= NVRAM_CUSTPACK_TOTAL, custpack_idx, file_idx, NVRAM_CUSTPACK_TOTAL);
        EXT_ASSERT(custpack_idx <= NVRAM_CUSTPACK_TOTAL && file_idx <= NVRAM_CUSTPACK_TOTAL, 0, NVRAM_LOC_GEN_TARGET_ASYNC_CUSTPACK, (custpack_idx > file_idx ? (custpack_idx): file_idx));

    }while(nvram_util_next_data_item(&ldi));

#endif  /* __NVRAM_SUPPORT_CUSTPACK__ */
#endif /* !defined(NVRAM_NOT_PRESENT) && !defined(__L1_STANDALONE__) */
#endif  /* __MMI_FMI__ */
}


/*****************************************************************************
 * FUNCTION
 *  nvram_assign_system_record_default_value
 * DESCRIPTION
 *  This function construct the default value of system record.
 * PARAMETERS
 *  des_str_sys_rec     :[out] point of the string of des system record.
 *  source_str_sys_rec  :[in ] point of the string of source system record.
 * RETURNS
 *  point of the string of des system record
 *****************************************************************************/
kal_char * nvram_assign_system_record_default_value(kal_char *des_str_sys_rec, const kal_char *source_str_sys_rec, kal_bool locked)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint8* CODED_PADDING = (kal_uint8*)"\x00\xDD\xC5\xB9";

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_mem_set(des_str_sys_rec, 0, NVRAM_EF_SYS_SIZE);

    /**
    * If length of returned verno is larger than maximum capacity,
    * truncate it to retain tail `CODED_DATA_VERSION_SIZE' bytes, and
    * use it as coded_version.
    * Note that maximum capacity is exactly CODED_DATA_VERSION_SIZE,
    * instead of (CODED_DATA_VERSION_SIZE - 1); because CODED_PADDING
    * guarantees to terminated it with zero.
    */
    if (strlen(source_str_sys_rec) > CODED_DATA_VERSION_SIZE)
    {
        kal_uint16 len = strlen(source_str_sys_rec) - CODED_DATA_VERSION_SIZE;

        source_str_sys_rec += len;
    }

    /* code version */
    strncpy(des_str_sys_rec, source_str_sys_rec, CODED_DATA_VERSION_SIZE);

    /* code padding */
    kal_mem_cpy(des_str_sys_rec + CODED_DATA_VERSION_SIZE, CODED_PADDING, CODED_PADDING_SIZE);

    if (locked)
    {
    /* lock pattern */
        kal_mem_cpy(
                    des_str_sys_rec + CODED_DATA_VERSION_SIZE + CODED_PADDING_SIZE,
                    NVRAM_LOCK_PATTERN_LOCKED,
                    CODED_LOCK_PATTERN_SIZE);
    }
    else
    {
        /* unlock pattern */
        kal_mem_cpy(
                    des_str_sys_rec + CODED_DATA_VERSION_SIZE + CODED_PADDING_SIZE,
                    NVRAM_LOCK_PATTERN_UNLOCKED,
                    CODED_LOCK_PATTERN_SIZE);
    }

    /*
     * Though system-level record is confidential, the attribute is not defined here.
     * It is controlled by NVRAM Layer directly.
     */
    custom_nvram_encrypt(
        nvram_ptr->secret_key,
        (unsigned char *)(des_str_sys_rec + CODED_LOCK_PATTERN_OFFSET),
        CODED_LOCK_PATTERN_SIZE, 0);
    return des_str_sys_rec;
}

/*****************************************************************************
 * FUNCTION
 *  nvram_pre_init
 * DESCRIPTION
 *  This function init necessary NVRAM information.
 *  (no matter NVRAM task is on or not)
 * PARAMETERS
 *  void
 * RETURNS
 *  NVRAM_ERRNO_SUCCESS if succeed, NVRAM_ERRNO_INVALID otherwise (ie, invalid LID).(?)(?)
 *****************************************************************************/
static void nvram_assign_table_entry(nvram_lid_enum position, nvram_ltable_entry_struct* ldi)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    //Tool check begin: nvram_pre_gen.pl check if it is same as nvram_assign_table_entry() and nvram_gen_assign_entry() 
    //***************************************************************************
    // Adjust Attr/Category I
    //     Do not need multiple attribute if nvram saved on nor flash
    //***************************************************************************
#if !defined(_NAND_FLASH_BOOTING_) && !defined(__FS_SYSDRV_ON_NAND__)
    if (ldi->LID != NVRAM_EF_SYS_LID)
    {
         NVRAM_TURNOFF_ATTR_MULTIPLE(ldi->attr);
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category II
    //     MULTIPLE / BACKUP_RAW / BACKUP_FAT  are mutually exclusive
    //***************************************************************************
    if (NVRAM_IS_CATEGORY_CALIBRAT(ldi->category))
    {
    #if defined(__NVRAM_BACKUP_DISK_FAT__)
        ldi->attr &= ~NVRAM_ATTR_MULTIPLE;
        ldi->attr &= ~NVRAM_ATTR_BACKUP_RAW;
        ldi->attr |= NVRAM_ATTR_BACKUP_FAT;
    #elif defined(__NVRAM_BACKUP_DISK_RAW__)
        ldi->attr &= ~NVRAM_ATTR_MULTIPLE;
        ldi->attr |= NVRAM_ATTR_BACKUP_RAW;
        ldi->attr &= ~NVRAM_ATTR_BACKUP_FAT;
    #else
        #if !defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__CCCIFS_SUPPORT__)
        ldi->attr |= NVRAM_ATTR_MULTIPLE;
        #endif
        ldi->attr &= ~NVRAM_ATTR_BACKUP_RAW;
        ldi->attr &= ~NVRAM_ATTR_BACKUP_FAT;
    #endif
    }

    //***************************************************************************
    // Adjust Attr/Category III
    //     Just apply to smartphone
    //     1: When AP side clean boot, nvram will reset all lid
    //     2: When Modern side restore factory, nvram only reset data item in NVD_DATA
    //        and don't care about data item in folder A & B
    //     3: So, turn off NVRAM_CATEGORY_FACTORY
    //***************************************************************************
#if defined(__CCCIFS_SUPPORT__)
    if (NVRAM_IS_CATEGORY_CALIBRAT(ldi->category))
    {
        NVRAM_TURNOFF_ATTR_FACTOY_RESET(ldi->attr);
    }
    if (NVRAM_IS_CATEGORY_IMPORTANT(ldi->category) || NVRAM_IS_CATEGORY_IMPORTANT_L4(ldi->category))
    {
        NVRAM_TURNOFF_ATTR_FACTOY_RESET(ldi->attr);
        ldi->attr |= NVRAM_ATTR_COMMITTED;
        ldi->attr |= NVRAM_ATTR_AUTO_RECOVER;
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category IV
    //       OTP category cannot use with many attribute together. Because it cannot be reset
    //       OTP category also cannot use with other category together.
    //***************************************************************************
#ifdef __NVRAM_OTP__
    if (NVRAM_IS_CATEGORY_OTP(ldi->category))
    {
        //ldi->category = NVRAM_CATEGORY_OTP;
        ldi->attr &= ~(NVRAM_ATTR_WRITEPROTECT);
        ldi->attr &= ~(NVRAM_ATTR_MULTIPLE);
        ldi->attr &= ~(NVRAM_ATTR_MSP);
        ldi->attr &= ~(NVRAM_ATTR_SW_VERNO_RESET);
        ldi->attr &= ~(NVRAM_ATTR_FACTORY_RESET);
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category V
    //      Add pseudo merge attribute
    //***************************************************************************
    /* Record data item will be restored (end) */
#ifdef __NVRAM_PSEUDO_MERGE__
    if (!NVRAM_IS_CATEGORY_INTERNAL(ldi->category) &&
        !NVRAM_IS_CATEGORY_SECUPACK(ldi->category) &&
        !NVRAM_IS_CATEGORY_IMPORTANT(ldi->category) &&
        !NVRAM_IS_CATEGORY_CALIBRAT(ldi->category) &&
    #ifdef __NVRAM_CUSTOM_SENSITIVE__
        !NVRAM_IS_CATEGORY_CUSTOM_SENSITIVE(ldi->category) &&
    #endif
    #ifdef __NVRAM_CUSTOM_DISK__
        !NVRAM_IS_CATEGORY_CUSTOM_DISK(ldi->category) &&
    #endif
          ((ldi->size + NVRAM_CHKSUM_SIZE) * ldi->total_records < NVRAM_CLUSTER_SIZE))
    {
        ldi->attr |= NVRAM_ATTR_PACKAGE;
    }

    if (NVRAM_IS_ATTR_PACKAGE(ldi->attr))
    {
        ldi->description = NULL;
        ldi->attr &= ~ (NVRAM_ATTR_MULTIPLE);
        ldi->attr &= ~ (NVRAM_ATTR_MSP);
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category V
    //      Add multiple attribute with msp together
    //***************************************************************************
    if (ldi->attr & NVRAM_ATTR_MSP)
    {
    #ifdef __NVRAM_BIND_TO_CHIP_CIPHER__
        /* we support msp with pseudo merge too, but do not turn on multiple in this case */
        if (!(ldi->attr & NVRAM_ATTR_PACKAGE))
        {
            ldi->attr |= NVRAM_ATTR_MULTIPLE;
        }
    #else
        ldi->attr &= ~(NVRAM_ATTR_MSP);
    #endif
    }

    //***************************************************************************
    // Adjust Attr/Category VI
    //      Add MSP, confidential, multiple with secupack item
    //***************************************************************************

    if (NVRAM_IS_CATEGORY_SECUPACK(ldi->category))
    {
    #ifdef __NVRAM_BIND_TO_CHIP_CIPHER__
        ldi->attr |= NVRAM_ATTR_MSP;
    #endif
        ldi->attr |= NVRAM_ATTR_CONFIDENTIAL;
        ldi->attr |= NVRAM_ATTR_MULTIPLE;
    }

    //***************************************************************************
    // Adjust Attr/Category VII
    //      Add MSP, confidential, multiple with custom sensitve data
    //***************************************************************************

#ifdef __NVRAM_CUSTOM_SENSITIVE__
    if (NVRAM_IS_CATEGORY_CUSTOM_SENSITIVE(ldi->category))
    {
    #ifdef __NVRAM_BIND_TO_CHIP_CIPHER__
        ldi->attr |= NVRAM_ATTR_MSP;
    #endif
        ldi->attr |= NVRAM_ATTR_CONFIDENTIAL;
        ldi->attr |= NVRAM_ATTR_MULTIPLE;
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category VIII
    //      remove all attribute if the data is in custom disk
    //***************************************************************************
#ifdef __NVRAM_CUSTOM_DISK__
    if (NVRAM_IS_CATEGORY_CUSTOM_DISK(ldi->category))
    {
        ldi->attr = NVRAM_ATTR_AVERAGE;
    }
#endif

    //***************************************************************************
    // Adjust Attr/Category X
    //      1. Compress the data in MT table and it is in custpack
    //      2. Compress the default value of the data not in MT table
    //         and its default value is not zero default or ff default
	// coppress function had phaseout
    //***************************************************************************

    //***************************************************************************
    // Adjust Attr/Category XI
    //      Put Internal, Calibration, Important data into SDS
    //***************************************************************************
#if defined(__NVRAM_SECURE_DATA_STORAGE__)
    if (NVRAM_IS_CATEGORY_INTERNAL(ldi->category) ||
        NVRAM_IS_CATEGORY_CALIBRAT(ldi->category) ||
        NVRAM_IS_CATEGORY_IMPORTANT(ldi->category) ||
        NVRAM_IS_CATEGORY_IMPORTANT_L4(ldi->category))
    {
        ldi->category |= NVRAM_CATEGORY_BACKUP_SDS;
        ldi->attr |= NVRAM_ATTR_FACTORY_RESET;

        ldi->attr &= ~ NVRAM_ATTR_MULTIPLE;
        ldi->attr &= ~ NVRAM_ATTR_RING;
        ldi->attr &= ~ NVRAM_ATTR_PACKAGE;
        ldi->attr &= ~ NVRAM_ATTR_BACKUP_FAT;
        ldi->attr &= ~ NVRAM_ATTR_BACKUP_RAW;
    }
#endif
	//Tool check end: nvram_pre_gen.pl

    //***************************************************************************
    //  Assign entry I
    //      Assign the secupack
    //***************************************************************************
    if (NVRAM_IS_CATEGORY_SECUPACK(ldi->category))
    {
        nvram_assign_secupack_entry(ldi);
    }

    //***************************************************************************
    //  Assign entry II
    //      Assign the pseudo merge, nvram will use ldi->description as file offset
    //***************************************************************************

#ifdef __NVRAM_PSEUDO_MERGE__
    ldi->description = NULL;
#endif


}

/*****************************************************************************
 * FUNCTION
 *  nvram_assign_cat_entry
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *****************************************************************************/
static void nvram_assign_cat_default_value(nvram_lid_enum position, nvram_cat_replace_setting* cat_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ltable_entry_struct *ldi;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    nvram_util_get_data_item(&ldi, position);

    if (cat_item->size != ldi->size ||
        cat_item->total_records != ldi->total_records)
    {
        return;
    }

    ldi->default_value = cat_item->default_value;

    if (cat_item->is_multi_default)
    {
        ldi->attr &= NVRAM_ATTR_MULTI_DEFAULT;
    }
    else
    {
        ldi->attr &= ~NVRAM_ATTR_MULTI_DEFAULT;
    }
}

/*****************************************************************************
 * FUNCTION
 *  ltable_construct
 * DESCRIPTION
 *  Constructor of ltable. Calculate  Record ID according to each logical data item's
 *  attributes.
 * PARAMETERS
 *  ltable          [IN/OUT]        The user configured logical data item table.
 * RETURNS
 *  void
 *****************************************************************************/
static nvram_ltable_entry_struct *tbl_p;
void nvram_set_ltable(nvram_ltable_entry_struct *table)
{
    tbl_p = (table>logical_data_item_table_internal)?table:logical_data_item_table_internal;
}

nvram_ltable_entry_struct *nvram_get_ltable(void)
{
    return tbl_p;
}

static void nvram_assgn_ltable(void)
{
#ifdef __MTK_TARGET__
    extern kal_uint32 _nvram_ltable$$Base, _nvram_ltable$$Length;

    logical_data_item_table = (nvram_ltable_entry_struct *)&_nvram_ltable$$Base;
    nvram_ptr->ltable.table = &logical_data_item_table;
    nvram_ptr->ltable.area_size = (kal_uint32)&_nvram_ltable$$Length;
    nvram_ptr->ltable.total_LID = nvram_ptr->ltable.area_size/sizeof(nvram_ltable_entry_struct);

    
#else
    kal_uint32 i;
    nvram_ltable_entry_struct *ltable_entry = NULL;
    nvram_ltable_entry_struct *the_start = &_nvram_ltable_start;
    kal_uint32 start_addr = (kal_uint32)the_start, end_addr = (kal_uint32)&the_nvram_ltable_end;

    for (i = 0; (kal_uint32)ltable_entry <= end_addr; i++)
    {
        ltable_entry = &the_start[i];
        if (logical_data_item_table == NULL && ltable_entry->fileprefix[0])
        {
            logical_data_item_table = ltable_entry;
            nvram_ptr->ltable.table = &logical_data_item_table;
        }

        if (ltable_entry->fileprefix[0])
        {
            //printf("%03d: ltable[%d]:%x filename = %s\n", nvram_ptr->ltable.total_LID, ltable_entry->LID, ltable_entry, ltable_entry->fileprefix);
            nvram_ptr->ltable.total_LID++;
        }
        
    }

    nvram_ptr->ltable.area_size = (kal_uint32)ltable_entry - (kal_uint32)logical_data_item_table;

#endif
}

void nvram_ltable_construct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 i = 0;
    nvram_ltable_entry_struct *ltable_entry;
#ifdef __NVRAM_PSEUDO_MERGE__
    kal_uint32 ldi_size = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/


    nvram_assgn_ltable();

    ltable_entry = &logical_data_item_table[0];
    do 
    {
        if (ltable_entry)
        {
        #ifdef __NVRAM_PSEUDO_MERGE__
            if (nvram_query_lid_merge(ltable_entry))
            {
                nvram_assign_package_entry(ltable_entry);
            }
        #endif /* __NVRAM_PSEUDO_MERGE__ */
        
            nvram_assign_table_entry(ltable_entry->LID, ltable_entry);
        }
        
    }while(nvram_util_next_data_item(&ltable_entry));
    
    
    /*
     * So far,logical table has been constructed
     */

    /*
     * Assign the custpack default value to ltable
     */
    nvram_assign_custpack_default_value();

    /*
     *  Assign the cat tool default value
     */
    i = 0;
    while (nvram_cat_replace_tbl[i].LID != NVRAM_EF_RESERVED_LID)
    {
        nvram_assign_cat_default_value(nvram_cat_replace_tbl[i].LID, &nvram_cat_replace_tbl[i]);
        i++;
    }

    /*
     * Assign the versions to ltable
     */

    /* First, define system-level record */


    /* Branch version */
    memset(nvram_ptr->branch_version, 0, NVRAM_EF_BRANCH_VERNO_SIZE + 1);
    strncpy((char*)nvram_ptr->branch_version, (char*)release_branch(), NVRAM_EF_BRANCH_VERNO_SIZE);

    /* Flavor version */
    memset(nvram_ptr->flavor_version, 0, NVRAM_EF_FLAVOR_VERNO_SIZE + 1);
    strncpy((char*)nvram_ptr->flavor_version, (char*)release_flavor(), NVRAM_EF_FLAVOR_VERNO_SIZE);

#ifdef __SECURE_RO_ENABLE__    
    /* Secupack version */
    nvram_ptr->secupack_version = nvram_get_secupack_verno();
    nvram_util_get_data_item(&ltable_entry, NVRAM_EF_SECUPACK_VERNO_LID);
    ltable_entry->default_value = (kal_uint8 *)&(nvram_ptr->secupack_version);
#endif

    /* Default lock status is LOCKED -- by using lock pattern of CODED_LOCK_PATTERN */
    nvram_assign_system_record_default_value((kal_char *)nvram_ptr->coded_version, release_verno(), nvram_custom_lock_status());


}   /* end of ltable_construct function */


#ifdef __NVRAM_OTP__


/*****************************************************************************
 * FUNCTION
 *  nvram_otp_construct
 * DESCRIPTION
 *  Construct OTP table.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void nvram_otp_construct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    kal_uint32 file_idx;
    nvram_ltable_entry_struct *ldi;
    kal_uint32 fs_otp_size = 0;
    nvram_lid_enum nvram_otp_idx = 0;
    kal_uint32 nvram_otp_size = 0;  /* if version is supported, init it as version length */
	nvram_drv_status_enum status;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ldi = &logical_data_item_table[0];
    do
    {

        if (ldi->category & NVRAM_CATEGORY_OTP)
        {
            ASSERT(nvram_otp_idx < NVRAM_OTP_TOTAL);

            nvram_otp_ltable[nvram_otp_idx].offset = nvram_otp_size;
            nvram_otp_size += ldi->size * ldi->total_records;

            nvram_otp_ltable[nvram_otp_idx].LID = ldi->LID;
            nvram_otp_idx++;
        }
    }while(nvram_util_next_data_item(&ldi));
#ifdef __MTK_TARGET__
    status = FS_OTPQueryLength(FS_DEVICE_TYPE_UNKNOWN, &fs_otp_size);
#else
    fs_otp_size = 256;
#endif
//    ASSERT(nvram_otp_size <= fs_otp_size);
    EXT_ASSERT(nvram_otp_size <= fs_otp_size, status, NVRAM_LOC_OTP_INIT_FAIL, fs_otp_size);

}

/*****************************************************************************
 * FUNCTION
 *  nvram_get_otp_offset
 * DESCRIPTION
 *  Construct OTP table.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
kal_uint32 nvram_get_otp_offset(nvram_lid_enum lid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i = NVRAM_OTP_TOTAL - 1; i >= 0 ; i--)
    {
        if (nvram_otp_ltable[i].LID == lid)
        {
            return nvram_otp_ltable[i].offset;
        }
    }

    ASSERT(0);

    return 0;
}


#endif /* __NVRAM_OTP__ */
