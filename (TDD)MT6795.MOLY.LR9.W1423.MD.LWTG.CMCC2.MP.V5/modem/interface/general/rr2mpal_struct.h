/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *  Modification Notice:
 *  --------------------------
 *  This software is modified by MediaTek Inc. and the information contained
 *  herein is confidential. The software may not be copied and the information
 *  contained herein may not be used or disclosed except with the written
 *  permission of MediaTek Inc. (C) 2001
 *
 *******************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *   rr2mpal_struct.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/


#ifndef _RR2MPAL_STRUCT_H
#define _RR2MPAL_STRUCT_H

/*Evelyn: Remove redundant header and file */
#include "rr_mpal_interface.h"
#include "l3_inc_enums.h"
#include "kal_general_types.h"
/*Justin: RHR*/
#ifdef __UMTS_RAT__
#include "uas_gas_enums.h"
#endif
#include "rr_common_def.h"
#include "gas_eas_enums.h"

#ifdef __GEMINI__
#include "rsvas_enum.h"
#endif /* __GEMINI__ */

#if defined(__UMTS_RAT__) || defined(__LTE_RAT__)
#define STANDBY_GSM_MEAS_MAX_CELL_NUM (32) // ref to MPH_STANDBY_GSM_MEAS_MAX_CELL_NUM
#define STANDBY_GSM_MAX_BSIC_NUM (32)      // ref to MPH_STANDBY_GSM_MEAS_MAX_CELL_NUM
#endif /* defined(__UMTS_RAT__) || defined(__LTE_RAT__) */

#ifdef __SGLTE__
#ifdef __OPEN_ORIGINAL_B3_B39_FEATURE__
#ifdef __OPEN_COMBIND_B3_B39_FEATURE__
#include "gas_b3_general_struct.h"
#endif
#endif
#include "gas_b3_general_struct.h"
#endif

typedef struct {
    kal_uint8 valid;
    kal_uint16 t1;
    kal_uint8 t2;
    kal_uint8 t3;
} starting_time_struct;

typedef struct {
    kal_uint8 is_value_valid;
    kal_uint8 value;
} timing_adv_struct;

typedef struct {
    kal_uint8 is_value_valid;
    kal_uint8 pwr_ctrl_level;
} pwr_cmd_struct;

typedef struct {
    kal_uint8 cipher_mode;
    kal_uint8 cipher_key[8];
} cipher_setting_struct;

typedef struct {
    kal_uint8 maio;
    kal_uint8 hsn;
    kal_uint8 length_of_list;
    kal_uint16 freq_list[64];
} hopping_freq_list_struct;

typedef struct {
    kal_uint16 arfcn;
    hopping_freq_list_struct hopping_freq_list;
} freq_comp_struct;

typedef struct {
    kal_bool is_hopping;
    kal_uint8 tsc;
#ifdef __VAMOS_1__
    kal_uint8 tsc_set; /* 0 or 1; only valid in handover_req and dedicated_channel_connect_req */
#endif
    freq_comp_struct freq_comp;
} freq_params_struct;

typedef struct {
    kal_uint8 time_slot;
    channel_type_enum ch_type;
    channel_mode_enum ch_mode;
    freq_params_struct freq_params;
} ch_connect_ctrl_params_struct;

typedef struct {
    kal_uint8 list_ref;
    kal_uint8 arfcn_list_len;
    kal_uint16 arfcn_list[33];
} bcch_list_struct;

typedef struct {
    kal_uint8 list_ref;
    kal_uint8 arfcn_list_len;

#ifdef __BA_RANGE__
    kal_uint16 arfcn_list[96];
#else
#if (defined __UMTS_TDD128_MODE__)
		kal_uint16 arfcn_list[65];
#else
    kal_uint16 arfcn_list[33];
#endif
#endif
} stored_bcch_list_struct;

typedef struct {
    kal_uint16 arfcn;
    kal_uint8 bsic_valid;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
    kal_uint8 need_retry;
    kal_uint8 retry_FB_SB;
} neighbor_bsic_acquisition_struct;

typedef struct {
    kal_uint16 arfcn;
    kal_uint8 is_need_freq_correction;
} cell_bsic_acquisition_struct;

typedef struct {
    kal_uint16 arfcn;
    kal_uint8 bsic_valid;
    kal_uint8 bsic;
    kal_uint16 bcch_mask;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
    kal_uint8 is_prior_to_acquire;
    kal_uint8 need_retry;
    kal_uint8 use_priority_index_order;
#ifdef __GEMINI_GSM__
    kal_uint16 priority_index; /*maruco20071107,RR may add more priorities for acquiring NBCCH.*/
#else
    kal_uint8 priority_index;
#endif/* end of __GEMINI_GSM__*/
} neighbor_bcch_acquisition_struct;

typedef struct {
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_uint16 bcch_mask;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
    kal_uint8 use_priority_index_order;
#ifdef __GEMINI_GSM__
    kal_uint16 priority_index; /*maruco20071107,RR may add more priorities for acquiring NBCCH.*/
#else
    kal_uint8 priority_index;
#endif /* end of __GEMINI_GSM__*/

#ifdef __GEMINI_GSM__
    /* Maruco20081125,GEMINI MAUI_91553,for BCCH_preempt_peer_PCH */
    kal_uint8 is_prior_to_acquire;
#endif
} cell_bcch_acquisition_struct;

typedef struct {
    kal_uint8 is_valid;
    kal_uint8 gamma;
} gamma_struct;

typedef struct {
    kal_uint8 alpha;
    kal_uint8 pb;
    kal_uint8 t_avg_w;
    kal_uint8 pc_meas_chan;
    kal_uint8 t_avg_t;
    gamma_struct gamma[8];
} pwr_ctrl_params_struct;

typedef struct {
    kal_uint8 is_valid;
    kal_uint8 value;
} usf_value_struct;

typedef struct {
    kal_uint8 is_value_valid;
    kal_uint8 value;
    kal_uint8 is_ul_valid;
    kal_uint8 ul_index;
    kal_uint8 ul_timeslot_no;
    kal_uint8 is_dl_valid;
    kal_uint8 dl_index;
    kal_uint8 dl_timeslot_no;
} pkt_timing_adv_struct;

typedef struct {
    kal_uint8 is_valid;
    kal_uint8 p0;
    kal_uint8 bts_pwr_ctrl_mode;
    kal_uint8 pr_mode;
} dl_pwr_ctrl_struct;

typedef struct {
    kal_uint8 blk_or_blk_period;
    kal_uint8 dl_ctrl_timeslot;
    kal_uint8 is_repeat_info_valid;
    kal_uint8 repeat_alloc;
    kal_uint8 ts_override;
    kal_uint16 alloc_bitmap_len;
    kal_uint8 alloc_bitmap[36];
} rr_fixed_alloc_struct;

typedef struct {
    kal_uint8 ul_tfi;
    kal_uint8 ul_timeslot_alloc;
    rr_fixed_alloc_struct fixed_alloc;
} ul_alloc_struct;

typedef struct {
    kal_uint8 dl_tfi;
    kal_uint8 dl_timeslot_alloc;
} dl_alloc_struct;

typedef struct {
    freq_params_struct freq_params;
#ifdef __PS_SERVICE__	
    ch_connect_ind_enum is_ch_connect_ind_needed;	
#else
    kal_uint8 is_ch_connect_ind_needed;
#endif
    kal_uint8 is_starting_frame_valid;
    kal_uint32 tbf_starting_frame;
    pkt_timing_adv_struct pkt_timing_adv;
    pwr_ctrl_params_struct pwr_ctrl_params;
    dl_pwr_ctrl_struct dl_pwr_ctrl;
    ul_alloc_struct ul_alloc;
    dl_alloc_struct dl_alloc;
} pdtch_ch_ctrl_struct;

typedef struct {
    kal_uint32 frame_number;
    kal_uint8 time_slot;
#ifdef __GERAN_RTTI__
    kal_uint8 time_slot_2;
#endif
    burst_type_enum burst_type;
    kal_uint8 no_data;
#ifdef MCD_PACK_UNPACK
    kal_uint8 data[23];
#else
    kal_uint8 *data;
#endif

#ifdef __GERAN_FANR__
    rlc_polling_type_enum polling_type;
    kal_bool is_pan_valid;
    kal_uint8 pan[4];
#endif

} ul_rrbp_block_struct;

typedef struct {
    kal_uint8 no_data;
#ifdef MCD_PACK_UNPACK
    kal_uint8 data[23];
#else
    kal_uint8 *data;
#endif
} ul_ctrl_block_struct;

typedef struct {
    kal_uint8 burst_type;
#ifdef MCD_PACK_UNPACK
    kal_uint8 data[75];
#else
    kal_uint8 *data;
#endif
  #ifdef __EGPRS_MODE__
#ifdef MCD_PACK_UNPACK
    kal_uint8 data2[75];
#else
    kal_uint8 *data2;          /* For MCS9~MCS7, there are 2 RLC blocks per radio block*/
#endif
    kal_uint8 header[6];
    kal_uint8 blockDataPS1;    // punturing scheme for EGPRS in the first RLC data block of one block
    kal_uint8 blockDataPS2;    // punturing scheme for EGPRS in the second RLC data block of one block
#endif

} ul_radio_blk_struct;

typedef struct{
    kal_uint8 transition_id;
    kal_uint8 is_starting_frame_valid;
    kal_uint32 tbf_starting_frame;
    kal_uint8 usf_granularity;
    usf_value_struct usf[8];
    kal_uint8 ul_tfi;
    kal_uint8 ul_timeslot_alloc;
    kal_uint8 type_of_allocation;
    /*There is no fix allocation in Rel-6*/
  #ifndef __REMOVE_FA__
    rr_fixed_alloc_struct fixed_alloc;
  #endif /*__REMOVE_FA__*/
  /* Evelyn: R7 Latency Reducation Development */
  #ifdef __GERAN_RTTI__
    kal_uint8 dl_timeslot_pair;
    tti_config_enum tti_mode;
    usf_mode_enum usf_mode;
  #endif
  #ifdef __GERAN_FANR__
    kal_bool is_fanr_active;
    kal_bool tan_type;
  #endif
}ul_tbf_params_struct;

typedef struct{
    kal_uint8 transition_id;
    kal_uint8 is_starting_frame_valid;
    kal_uint32 tbf_starting_frame;
    kal_uint8 dl_tfi;
    kal_uint8 dl_timeslot_alloc;
  #ifdef __EGPRS_MODE__
    kal_bool is_egprs_ackmode;
    kal_bool is_reset_ir_memory;
    kal_uint16 egprs_window_size;
  #endif
    kal_uint8 type_of_allocation;
  /* Evelyn: R7 Latency Reducation Development */
  #ifdef __GERAN_RTTI__
    tti_config_enum tti_mode;
  #endif
  #ifdef __GERAN_FANR__
    kal_bool is_fanr_activated;
    kal_bool is_event_based_fanr;
  #endif
}dl_tbf_params_struct;


#ifdef __GEMINI__
typedef enum{
    MPAL_SIM1_ONLY_CONFIG,
    MPAL_SIM2_ONLY_CONFIG,
    MPAL_DAUL_SIM_CONFIG
}mpal_sim_config_status_enum;

typedef enum{
    MPAL_NO_SIM_INSERTED,
    MPAL_ONLY_SIM1_INSERTED,
    MPAL_ONLY_SIM2_INSERTED,
    MPAL_DUAL_SIM_INSERTED
}mpal_sim_insert_status_enum;	
#endif /* end of __GEMINI__*/

#if defined (__AMR_SUPPORT__) || defined (__AMRWB_LINK_SUPPORT__)
typedef enum{
    AMR_SPEECH_VERSION_1 = 1
#ifdef __AMRWB_LINK_SUPPORT__
   ,AMR_SPEECH_VERSION_2 = 2
#endif //__AMRWB_LINK_SUPPORT_
}multirate_speech_version_enum;
#endif /* __AMR_SUPPORT__ || __AMRWB_LINK_SUPPORT__*/

#ifdef __PS_SERVICE__
#ifdef __PS_HO__
/* Enum number of PS handover type is different from CS handover type*/
typedef enum{
    MPAL_PS_HANDOVER_TYPE_NON_SYNC,
    MPAL_PS_HANDOVER_TYPE_FINELY_SYNC,
    MPAL_PS_HANDOVER_TYPE_PRE_SYNC
}ps_handover_type_enum;	

#ifdef __EGPRS_MODE__
typedef enum{
    MPAL_ResetNoVQIR ,
    MPAL_ResetAllVQIR,
    MPAL_ResetAllIR,
    MPAL_RestoreAllVQ
}ir_control_enum; /* IR: incremental redundancy */
#endif /* end of __EGPRS_MODE__ */

typedef struct{
    kal_bool is_valid;
    burst_type_enum burst_type;	
    kal_uint16 handover_ref;	
}ps_handover_ref_struct;

typedef struct{
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_bool timing_info_valid;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
    kal_int8 tx_pwr;
    kal_bool is_tx_pwr_pccch_valid;
    kal_int8 tx_pwr_pccch;
#ifdef __GERAN_R6__ 
    kal_bool LB_valid;
    kal_int8 tx_pwr_LB;
#endif /*__GERAN_R6__ */	
}target_cell_params_struct;

#endif /* end of __PS_HO__ */
#endif /* end of __PS_SERVICE__ */

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 scan_id;
    kal_uint8 bands_scan;
    kal_uint8 bcch_list_valid;
    kal_uint8 is_for_plmn_list;
    stored_bcch_list_struct bcch_list;
} rr_mpal_search_rf_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 scan_id;
} rr_mpal_search_rf_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 arfcn;
    kal_uint8 is_need_freq_correction;
} rr_mpal_bsic_sync_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 arfcn_sync;
    kal_uint8 bsic;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
} rr_mpal_specific_sync_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 arfcn;
    kal_uint16 mask;
#ifdef __GEMINI_GSM__
    /* Maruco20081125,GEMINI MAUI_91553,for BCCH_preempt_peer_PCH */
    kal_uint8 is_prior_to_acquire;
#endif
} rr_mpal_serv_bcch_monitor_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 imsi_valid;
    kal_uint16 imsi_mod_1000;
    kal_uint8 bs_pa_mfrms;
    kal_uint8 bs_ag_blks_res;
    kal_uint8 ccch_conf;
    rr_mode_enum rr_mode;
    kal_uint8 alpha;            /* Austin: 040709: alpha should not be removed */
    kal_uint8 t_avg_w;
    kal_uint8 pc_meas_chan;
    kal_uint8 t_avg_t;
    /* Austin: for NMO III, for curcurrent ccch & pccch monitoring */
    kal_uint8 monitor_required;
} rr_mpal_ccch_monitor_req_struct;

#ifdef __MONITOR_PAGE_DURING_TRANSFER__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 imsi_valid;
    kal_uint16 imsi_mod_1000;
    kal_uint8 bs_pa_mfrms;
    kal_uint8 bs_ag_blks_res;
    kal_uint8 ccch_conf;
    kal_uint8 paging_mode;
    kal_uint8 smart_bs_pa_mfrms;
    kal_uint8 smart_mfrms_group_offset;
} rr_mpal_monitor_page_in_ptm_start_req_struct;
#endif /* __MONITOR_PAGE_DURING_TRANSFER__ */

#ifdef __SMART_PAGING_IN_IDLE__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 imsi_valid;
    kal_uint16 imsi_mod_1000;
    kal_uint8 bs_pa_mfrms;
    kal_uint8 bs_ag_blks_res;
    kal_uint8 ccch_conf;
    kal_uint8 smart_bs_pa_mfrms;
    kal_uint8 smart_mfrms_group_offset;
    //kal_uint8 paging_mode;
} rr_mpal_smart_page_start_req_struct;
#endif /* __SMART_PAGING_IN_IDLE__ */

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 paging_mode;
    /* Austin: for NMO III, page mode changes of ccch and pccch are handled separately  */
    kal_uint8 page_channel_type;
} rr_mpal_page_mode_change_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 req_id;  /*sequence number for RR to know the ._cnf received is old or new*/
    burst_type_enum burst_type;
    rach_req_type_enum req_type;
    kal_uint16 rach_data;
    kal_uint16 rand;
  #ifdef __EGPRS_MODE__
    ats_type_enum ats_type;     /* synch. sequence bits type, TS05.02 clause 5.2.7 */
  #endif  
} rr_mpal_rach_req_struct;


#if defined (__AMR_SUPPORT__) || defined (__AMRWB_LINK_SUPPORT__)
/***************************************************************************
*  PRIMITIVE STRUCTURE
*     rr_mpal_amr_req_struct
*
*  DESCRIPTION
*     This struct is sent from RR to MPAL with rr_mpal_dedicated_channel_connect_req_struct
*
***************************************************************************/
typedef struct
{
   kal_bool amr_valid; /* the AMR(TRUE) or not(FALSE) */
//   kal_uint32 frame_number;/* the frame number to get RATSCCH messages */
//   kal_uint8 cmip;  /* CMI phase */

   /*ZY: add for AMR-WB*/
   multirate_speech_version_enum mr_ver; /* MultiRate speech VERsion : 001-amr verion 1*/

   kal_bool nscb;      /* Noise Supression Control Bit : 0-noise supression is used */
   kal_bool icmi;       /* Initial Codec Mode Indicator : 0-is defined bythe implicit rule */
   kal_uint8 start_codec_mode; /* Start Codec Mode */
   kal_uint8 acs;       /* AMR Codec Activate Set */
   kal_uint8 threshold[3]; /* Threshold1/Threshold2/Threshold3 */
   kal_uint8 hysteresis[3]; /* Hysteresis1/Hysteresis2/Hysteresis3 */
} rr_mpal_amr_req_struct;
#endif /* __AMR_SUPPORT__ || __AMRWB_LINK_SUPPORT__*/
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 req_type;
    kal_uint8 dtx_allowed;
    kal_uint8 pwrc;
    timing_adv_struct timing_advance;
    pwr_cmd_struct pwr_cmd;
    starting_time_struct starting_time;
    kal_uint8 before_time_channel_valid;
    cipher_setting_struct cipher_set;
    ch_connect_ctrl_params_struct before_time_channel;
    ch_connect_ctrl_params_struct after_time_channel;
#if defined (__AMR_SUPPORT__) || defined (__AMRWB_LINK_SUPPORT__)
    rr_mpal_amr_req_struct rr_mpal_amr_para;
#endif /* __AMR_SUPPORT__ || __AMRWB_LINK_SUPPORT__*/
#ifdef __VAMOS_2__
    kal_uint8 vamos_level; /* To config L1 non-VAMOS, VAMOS1, or VAMOS2 */
#endif /* __VAMOS_2__ */
} rr_mpal_dedicated_channel_connect_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 handover_type;
    handover_atc_enum atc;
    kal_uint8 dtx_allowed;
    starting_time_struct starting_time;
    timing_adv_struct timing_advance;
    pwr_cmd_struct pwr_cmd;
    cipher_setting_struct cipher_set;
    kal_uint8 before_time_channel_valid;
    ch_connect_ctrl_params_struct before_time_channel;
    ch_connect_ctrl_params_struct after_time_channel;
    kal_uint8 handover_ref;
    kal_uint8 rtd_valid;
    kal_uint8 rtd;
    kal_uint8 ncc;
    kal_uint8 bcc;
    kal_uint8 nci;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
    kal_uint16 target_bcch_arfcn;
#if defined (__AMR_SUPPORT__) || defined (__AMRWB_LINK_SUPPORT__)
    rr_mpal_amr_req_struct rr_mpal_amr_para;
#endif  /* __AMR_SUPPORT__ || __AMRWB_LINK_SUPPORT__*/
#ifdef __BLIND_HANDOVER__
    kal_bool is_blind_handover_req;
#endif /*__BLIND_HANDOVER__*/
} rr_mpal_handover_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 timing_advance;
} rr_mpal_handover_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 is_freq_in_one_band;
    starting_time_struct starting_time;
    freq_params_struct freq_def;
} rr_mpal_frequency_redefinition_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    channel_mode_enum ch_mode;
    kal_uint8 dtx_allowed;
#if defined (__AMR_SUPPORT__) || defined (__AMRWB_LINK_SUPPORT__)
    rr_mpal_amr_req_struct rr_mpal_amr_para;
#endif /* __AMR_SUPPORT__  || __AMRWB_LINK_SUPPORT__*/
} rr_mpal_channel_mode_modify_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    cipher_setting_struct cipher_cmd;
} rr_mpal_ciphering_mode_command_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_int8 loopback_type;
} rr_mpal_close_tch_loop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 device;
} rr_mpal_dai_test_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 dtx_allowed;
    kal_uint8 pwrc;
} rr_mpal_cell_option_update_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 cause;  /*current no use*/
} rr_mpal_dedicated_channel_disconnect_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_int8 gsm450_power_class;
    kal_int8 gsm480_power_class;
    kal_int8 gsm850_power_class;
    kal_int8 gsm900_power_class;
    kal_int8 dcs_power_class;
    kal_int8 pcs_power_class;
    kal_int8 tx_pwr;
    kal_int8 tx_pwr_pccch;
    change_cause_enum change_cause;
    /*Pop 090420 add for support to E2 in 8-PSK*/
#ifdef __EPSK_TX__
    kal_int8 gsm450_power_class_8psk;
    kal_int8 gsm480_power_class_8psk;
    kal_int8 gsm850_power_class_8psk;
    kal_int8 gsm900_power_class_8psk;
    kal_int8 dcs_power_class_8psk;
    kal_int8 pcs_power_class_8psk;
#endif
#ifdef __GERAN_R6__ 
    kal_int8 tx_pwr_LB;
    kal_bool LB_valid;
#endif /*__GERAN_R6__ */
} rr_mpal_power_class_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    bcch_list_struct ext_meas_freq_list;
} rr_mpal_extended_meas_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    nbr_meas_mode_enum meas_mode;
    kal_uint8 is_ba_list_valid;
    bcch_list_struct ba_list;
} rr_mpal_neighbor_meas_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 burst_access_id;
#ifdef __PKT_EXT_MEAS__
    kal_uint8 is_for_extended_meas;
#endif
    kal_uint8 list_len;
    neighbor_bsic_acquisition_struct neighbor_bsic_acquisition_list[33];
} rr_mpal_neighbor_bsic_start_req_struct;

typedef struct {
    LOCAL_PARA_HDR
#ifdef __PKT_EXT_MEAS__
    kal_uint8 is_for_extended_meas;
#endif
    kal_uint8 list_len;
    kal_uint16 neighbor_bsic_acquisition_stop_list[33];
} rr_mpal_neighbor_bsic_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    neighbor_bcch_acquisition_struct nbcch_acquisition_list[1];
    kal_uint8 is_prior_to_pdtch_rx;
} rr_mpal_neighbor_sys_info_read_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 list_len;
    kal_uint16 nbcch_acquisition_stop_list[1];
    kal_uint8 manual_list;  /* 1: stop the manual list, 0: stop the neighbor list */
} rr_mpal_neighbor_sys_info_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 burst_access_id;
    kal_uint8 list_len;
    cell_bsic_acquisition_struct cell_bsic_acquisition_list[33];
} rr_mpal_cell_bsic_start_req_struct;

typedef struct {
    LOCAL_PARA_HDR
} rr_mpal_cell_bsic_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    cell_bcch_acquisition_struct cell_bcch_acquisition_list[1];
} rr_mpal_cell_sys_info_read_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 list_len;
    kal_uint16 cell_bcch_acquisition_stop_list[1];
} rr_mpal_cell_sys_info_stop_req_struct;

/* 2013/1/2 James: new primitive to adjust prority */
#ifdef __GEMINI__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 arfcn;
    kal_uint8 is_prior_to_acquire;
} rr_mpal_cell_sys_info_pri_adjust_req_struct;
#endif /* __GEMINI__ */

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 pb;
    kal_uint8 timeslot_alloc;
    freq_params_struct freq_params;
    kal_uint8 bs_pbcch_blks;
    kal_uint8 psi1_repeat_period;
    kal_uint8 psi_count_hr;
#ifdef __PS_SERVICE__
    psi_mode_enum psi_reading_mode;
#else
    kal_uint8 psi_reading_mode;	
#endif
} rr_mpal_monitor_pbcch_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    freq_params_struct freq_params;
    kal_uint8 timeslot_alloc;
    pwr_ctrl_params_struct pwr_ctrl_params;
    kal_uint16 imsi_mod_1000;
    kal_uint16 split_pg_cycle;
    kal_uint16 kcn;
    kal_uint8 bs_pag_blks_res;
    kal_uint8 bs_pbcch_blks;
} rr_mpal_monitor_pccch_req_struct;

#ifdef __SGLTE__
#ifdef __OPEN_ORIGINAL_B3_B39_FEATURE__
#ifndef __OPEN_COMBIND_B3_B39_FEATURE__
typedef struct {
    LOCAL_PARA_HDR
    rat_enum rat_mode_params;
} rr_mpal_enable_b39_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    rat_enum rat_mode_params;
} rr_mpal_disable_b39_req_struct;
#else
typedef struct {
    LOCAL_PARA_HDR
} rr_mpal_enable_b39_req_struct;

typedef struct {
    LOCAL_PARA_HDR
	kal_bool is_disable_valid;
	kal_uint8 list_len;
	gl1_b3_info_struct b3_info_list[MULTIPLE_B3_INFO_NUM];
} rr_mpal_disable_b39_req_struct;
#endif
#else
typedef struct {
    LOCAL_PARA_HDR
} rr_mpal_enable_b39_req_struct;

typedef struct {
    LOCAL_PARA_HDR
	kal_bool is_disable_valid;
	kal_uint8 list_len;
	gl1_b3_info_struct b3_info_list[MULTIPLE_B3_INFO_NUM];
} rr_mpal_disable_b39_req_struct;
#endif
#endif

typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 c0_arfcn;
    kal_uint8 pb;
    kal_uint8 timeslot_alloc;
    freq_params_struct freq_params;
    kal_uint8 bs_pbcch_blks;
    kal_uint8 psi1_repeat_period;
#ifdef __PS_SERVICE__
    psi_mode_enum psi_reading_mode;
#else
    kal_uint8 psi_reading_mode;	
#endif
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
} rr_mpal_ncell_pbcch_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 nc_reporting_period_i;
    kal_uint8 nc_reporting_period_t;
} rr_mpal_nc_measurement_req_struct;

#ifdef __PKT_EXT_MEAS__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 list_len;
    kal_uint16 ext_freq_list[32];
} rr_mpal_pkt_ext_measurement_req_struct;
#endif /*__PKT_EXT_MEAS__*/

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 carrier_ref;
    freq_params_struct freq_params;
    kal_uint8 ts_allocation;
} rr_mpal_int_measurement_req_struct;


   typedef struct {
    LOCAL_PARA_HDR
    freq_params_struct freq_params;
    pkt_timing_adv_struct pkt_timing_adv;
    pwr_ctrl_params_struct pwr_ctrl_params;
    dl_pwr_ctrl_struct dl_pwr_ctrl;
    kal_uint8 is_ptcch_8bit_access;
  #ifdef __EGPRS_MODE__
    kal_bool is_egprs;
  #endif
  #ifdef __REL4__
   kal_uint8 ext_utbf_nodata;   /* 0: PUDCB must be sent (delayed uplink TBF not supported)
                                                     1: PUDCB may not be sent (delayed uplink TBF supported) */
   #endif /* __REL4__ */
   kal_uint8 ul_tbf_bitmap;
   kal_uint8 dl_tbf_bitmap;
   ul_tbf_params_struct ul_tbf_params[MAX_TBF_NUM];
   dl_tbf_params_struct dl_tbf_params[MAX_TBF_NUM];
#ifdef __PS_HO__
   /* Maruco20090720, MAUI1720041, To notify L1C whether this is the reconnected pending TBF after PS handover */
   kal_bool is_pending_tbf_after_ps_ho;
#endif /* end of __PS_HO__ */
} rr_mpal_pdtch_connect_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 type_of_allocation;
    kal_uint8 identity;
    kal_uint8 usf_granularity;
    usf_value_struct usf[8];
    kal_uint8 is_before_params_valid;
    pdtch_ch_ctrl_struct pdtch_chan_params_before;
    pdtch_ch_ctrl_struct pdtch_chan_params_after;
    kal_uint8 direction;
    kal_uint8 is_ul_nw_assign;
    kal_uint8 is_dl_nw_assign;
    kal_uint8 is_ptcch_8bit_access;
} rr_mpal_pdch_assignment_req_struct;

#ifdef __EGPRS_MODE__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 egprs_loopback_on;
    kal_uint8 mode_flag;
} rr_mpal_egprs_loop_req_struct;
#endif
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 no_rrbp_blks;
    ul_rrbp_block_struct rrbp_blks[4];
} rr_mpal_rrbp_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 no_ctrl_blks;
    ul_ctrl_block_struct ctrl_blks[4];
} rr_mpal_ctrl_req_struct;

typedef struct {
    LOCAL_PARA_HDR
#ifdef __PS_SERVICE__	
    block_type_enum type_of_block;
#else
    kal_uint8 type_of_block;
#endif
    kal_uint8 no_ul_blks;
    ul_radio_blk_struct ul_blks[8];
    kal_uint8 tbf_index;
} rr_mpal_data_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 is_timing_adv_valid;
    pkt_timing_adv_struct pkt_timing_adv;
    kal_uint8 is_ptcch_8bit_access;
    kal_uint8 is_pwr_ctrl_valid;
    pwr_ctrl_params_struct pwr_ctrl_params;
} rr_mpal_pkt_timing_adv_pwr_ctrl_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 ts_available;
    kal_uint8 limit; /* 0: OLD, 1:ALL */
} rr_mpal_pdch_release_req_struct;

 typedef struct{
    LOCAL_PARA_HDR
    kal_bool is_all_tbf_rel;
    kal_uint8 ul_tbf_bitmap;
    kal_uint8 dl_tbf_bitmap;
    kal_uint8 identity;/* add identity for L1 */	
 }rr_mpal_pdtch_disconn_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    ch_connect_ctrl_params_struct ch_desc;
} rr_mpal_cbch_config_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 cbch_mode;
    kal_bool high_priority_on_cbch;    
} rr_mpal_cbch_start_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 cbch_mode;
} rr_mpal_cbch_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_int32 num_skip;
    kal_uint8 cbch_mode;
} rr_mpal_cbch_skip_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 status;
} rr_mpal_sim_ready_notify_req_struct;

#ifdef __EGPRS_MODE__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 tbf_resetIR;//the index of TBF to resetIR
}rr_mpal_update_ir_reset_req_struct;
#endif

typedef struct {
    LOCAL_PARA_HDR
    channel_type_enum ch_type;
    kal_uint8 is_bad_frame;
#ifdef __REPEATED_ACCH__
    kal_bool is_combined;
#endif
    kal_uint8 data[23];
} mpal_rr_dedicated_data_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    channel_type_enum ch_type;
    kal_uint8 is_bad_frame;
#ifdef __REPEATED_ACCH__
    kal_bool is_combined;
#endif
    kal_uint8 data[23];
} mpal_rr_dedicated_data_callback_ind_struct;

#if 0 //__UMTS_TDD128_MODE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __REPEATED_ACCH__
/* under construction !*/
#endif /* __REPEATED_ACCH__ */    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __REPEATED_ACCH__
/* under construction !*/
#endif /* __REPEATED_ACCH__ */
/* under construction !*/
#else
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 sap_id;
    kal_bool is_signalling;
    channel_type_enum ch_type;	
    kal_uint8 tch_type;
#ifdef __REPEATED_ACCH__
    kal_bool is_repetition;
#endif /* __REPEATED_ACCH__ */    
} rr_mpal_dedicated_data_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 sap_id;
    kal_bool is_signalling;
    channel_type_enum ch_type;
    kal_uint8 tch_type;
#ifdef __REPEATED_ACCH__
    kal_bool is_repetition;
#endif /* __REPEATED_ACCH__ */
} mpal_rr_dedicated_ready_to_send_ind_struct;
#endif

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 sap_id;
    channel_mode_enum ch_mode;
    channel_type_enum ch_type;
    kal_uint8 tch_type;
} mpal_rr_dedicated_ready_to_send_callback_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_bool result;
} rr_mpal_detect_paging_block_result_cnf_struct;

typedef struct {
    LOCAL_PARA_HDR
    system_mode_enum system_mode;
}rr_mpal_set_rat_service_req_struct;

#if defined(__UMTS_RAT__) || defined(__LTE_RAT__)
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 list_ref;
#ifdef __UMTS_TDD128_MODE__
    te_ir_urrc_state umts_rrc_state;
#endif /* __UMTS_TDD128_MODE__ */
    kal_uint8 list_len;
    kal_uint16 cell_list[STANDBY_GSM_MEAS_MAX_CELL_NUM];
   /* This flag is used to indicate whether measurement period should be reset
    * immediately (i.e., GAS measurement will be triggered for the first available
    * gap from other RAT). In current design, the following rules should be followed.
    * (1)If list_len != 0, this flag will be set as FALSE only if tmeas,gsm measurement 
    *                      is triggered when priority measurement is on-going (i.e., one 
    *                      of GSM cells hits priority reselection criteria for priority 
    *                      based measurement reselection). For other case, this flag should 
    *                      be set as TRUE. If any improvement is needed, the usage limitation 
    *                      for this flag should be confirmed with GL1's colleague.
    * (2) If list_len == 0, this flag will alwyas be set as FALSE;
    */
   kal_bool is_meas_period_reset;    
  
   /* When this flag is set to TRUE, the standby measurement will be performed every T-meas without */
   /* multiplying by N layers. So that there will be 2 measurement results within 10s OOS period, which */
   /* increases the successful rate of finding a candidate during OOS */
   kal_bool prohibit_apply_n_layer;
} rr_mpal_standby_gsm_meas_req_struct;

#if defined(__23G_PRI_RESEL_SUPPORT__) || defined(__LTE_RAT__)
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 list_ref;
    kal_uint8 list_len;
    kal_uint16 cell_list[STANDBY_GSM_MEAS_MAX_CELL_NUM];
    kal_uint16 period_in_second;
    /* This flag is used to indicate whether priority measurement period should be 
     * reset immediately in LL1 (i.e., GAS measurement will be triggered for the 
     * first available gap from other RAT). In current design, the following rules
     * should be followed.
     * (1) If list_len != 0, this flag will always be set as true becuase other active 
     *                       RAT will always need to obtain the priority measurement result 
     *                       from GL1 immediately.
     * (2) If list_len == 0, this flag will always be set as FALSE.
     */
    kal_bool is_prio_meas_period_reset;
} rr_mpal_standby_gsm_prio_meas_req_struct;
#endif /* defined(__23G_PRI_RESEL_SUPPORT__) || defined(__LTE_RAT__) */

typedef struct
{
   kal_uint16 arfcn;
   kal_uint8 bsic_valid;
   kal_int32 frame_offset;
   kal_int32 ebit_offset;
   kal_bool retry_FB_SB;
   kal_uint32 time_stamp;
   kal_bool is_enh_bsic_verify_used;
} mpal_standby_gsm_bsic_read_struct;

typedef struct
{
   LOCAL_PARA_HDR
   kal_uint8 list_len; /* The number of valid element in bsic_read_list */
   mpal_standby_gsm_bsic_read_struct cell_bsic_list[STADNBY_GSM_MAX_BSIC_NUM]; /* The database for BSIC read */
} rr_mpal_standby_gsm_bsic_read_req_struct;

typedef struct
{
   LOCAL_PARA_HDR
   kal_uint8 list_len; /* The number of valid element in bsic_stop_list */
   kal_uint16 stop_bsic_list[STADNBY_GSM_MAX_BSIC_NUM];  /* The database for BSIC stop */
} rr_mpal_standby_gsm_bsic_stop_req_struct;
   
#ifdef __PS_HO__
typedef struct {
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    kal_bool is_ps_handover;
} rr_mpal_inter_rat_handover_req_struct;
#endif /* __PS_HO__ */

#ifdef __LTE_RAT__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 scan_id;
    kal_uint16 arfcn;
} rr_mpal_standby_gsm_report_cgi_search_rf_req_struct; 

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 scan_id;
} rr_mpal_standby_gsm_report_cgi_search_rf_stop_req_struct;

typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 bsic_tid;
    kal_uint16 arfcn;
} rr_mpal_standby_gsm_report_cgi_bsic_start_req_struct;  

typedef struct {
    LOCAL_PARA_HDR
} rr_mpal_standby_gsm_report_cgi_bsic_stop_req_struct;   

typedef struct {
    LOCAL_PARA_HDR
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_uint16 bcch_mask;
    kal_int32 frame_offset;
    kal_int32 ebit_offset;
} rr_mpal_standby_gsm_report_cgi_sys_info_read_req_struct;

typedef struct {
    kal_uint8 ref_count;
    kal_uint16 msg_len;
} rr_mpal_standby_gsm_report_cgi_sys_info_stop_req_struct;
#endif /* __LTE_RAT__ */

/* make L1 keep the resource (gap) for next BSIC decoding activity */
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_standby_cell_bsic_res_required;
} rr_mpal_standby_cell_bsic_res_req_struct;

#endif /* defined(__UMTS_RAT__) || defined(__LTE_RAT__) */

#ifdef __UMTS_RAT__
#ifdef __UMTS_TDD128_MODE__
typedef struct {
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    kal_bool high_priority;
} rr_mpal_3g_search_priority_req_struct;
#endif
#endif /*__UMTS_RAT__ */

#if defined(__GEMINI__) || defined(__SGLTE__)
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 sim_config_status;
    kal_uint8 sim_insert_status;
} rr_mpal_sim_status_update_req_struct;
#endif

#ifdef __GEMINI__
/* __GEMINI_MONITOR_PAGE_DURING_TRANSFER__, Gemini 2.0 */
typedef struct {
    LOCAL_PARA_HDR
    kal_uint32 protected_channel;
} rr_mpal_channel_protect_start_req_struct;
/* __GEMINI_MONITOR_PAGE_DURING_TRANSFER__ */

typedef struct {
    LOCAL_PARA_HDR
    rsvas_sim_enum sim_in_transfer;
} rr_mpal_virtual_suspend_req_struct;

#endif/* end of __GEMINI_GSM__*/

#ifdef __PS_SERVICE__
#ifdef __PS_HO__
typedef struct {
    LOCAL_PARA_HDR
    kal_bool is_inter_rat_ps_handover; /* TRUE: 3G to 2G PS Handover*/
    ps_handover_type_enum handover_type;
    ps_handover_ref_struct ps_handover_ref;

    target_cell_params_struct target_cell_info;
    kal_bool nci; /* whether allow TA out of range */

    /* TBF parameters*/
    freq_params_struct freq_params; 
    pkt_timing_adv_struct pkt_timing_adv;
    pwr_ctrl_params_struct pwr_ctrl_params;
    dl_pwr_ctrl_struct dl_pwr_ctrl;
    kal_uint8 is_ptcch_8bit_access;
    kal_bool is_all_tbf_pending;
    /* For L1C to use in PS handover reconnect procedure,
     * If the TBF of old cell are all pending, it is TRUE. 
     * If the TBF of old cell are all active, it is FALSE. 
     * If the TBF of old cell are some active and some pending, RR will send 2 msg:
     * 1st msg is ps_handover_reconnect_req(all active), then RR sends 2nd msg after received CNF of 1st msg
     * the 2nd msg is ul/dl assign or ts_reconfig_req(all pending) */
    kal_uint8 ul_tbf_bitmap;
    kal_uint8 dl_tbf_bitmap;
    ul_tbf_params_struct ul_tbf_params[MAX_TBF_NUM];
    dl_tbf_params_struct dl_tbf_params[MAX_TBF_NUM];    

#ifdef __EGPRS_MODE__
    kal_bool is_egprs;
    ir_control_enum set_all_vq_ir; /* ps_ho_req:0,1,2 <-> ps_ho_reconnect_req:always 3 */
#endif /* end of __EGPRS_MODE__ */

#ifdef __REL4__
    kal_uint8 ext_utbf_nodata; /* 0: PUDCB must be sent (not support delayed UL TBF); 1: PUDCB may not be sent */
#endif /* end of __REL4__ */
} rr_mpal_ps_handover_req_struct,
rr_mpal_ps_handover_reconnect_req_struct,
rr_mpal_ps_handover_fill_params_struct;
#endif /* end of __PS_HO__ */
#endif /* end of __PS_SERVICE__ */

#ifndef __MTK_TARGET__
typedef struct {
    LOCAL_PARA_HDR
    kal_uint8 *no_rts_sent;
    kal_uint8 *total_blks_sent;
    kal_uint8 tbf_index;
} rr_mpal_flush_req_struct;
#endif

#endif


