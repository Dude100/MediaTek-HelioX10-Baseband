/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2006
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * nvram_auto_gen.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for generating NVRAM information.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef NVRAM_NOT_PRESENT
/*****************************************************************************
* Include
*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <sys/io.h>
#include <errno.h>

#include "nvram_auto_gen.h"
#include "custom_nvram_config.h"
#include "nvram_editor_data_item.h"
#include "nvram_data_items.h"

#if defined(__MMI_FMI__)
#include "nvram_user_defs.h"

#endif

#ifndef __VENDOR_RELEASE__
#include "custom_nvram_sec.h"
#endif

/* Add pseudo merge headfile */
#include "nvram_pseudo_merge.h"

#include "nvram_internal.h"
/*
 * Variables
 */
extern kal_uint32 custpack_total_to_verify;

extern nvram_ltable_entry_struct *logical_data_item_table;
extern kal_uint32 nvram_gen_total_lid;

#ifdef __NVRAM_OTP__
extern kal_uint32 otp_total_to_verify;
extern kal_uint32 otp_size_to_verify;
#endif

extern kal_uint32 secupack_total_to_verify;
extern kal_uint32 secupack_size_to_verify;
extern kal_uint16 secupack_idx;

#ifdef __NVRAM_VENDOR_SUPPORT__
extern kal_uint32 nvram_vendor_reserve_size;
#endif

#if defined(__NVRAM_SECURE_DATA_STORAGE__)
extern kal_uint32 sds_total_to_verify;
extern kal_uint32 sds_size_to_verify;
#endif


/* system cache configure*/
extern nvram_sys_cache_entry nvram_sys_cache[];

#define NVRAM_AUTO_GEN_BYTE       1
#define NVRAM_AUTO_GEN_SHORT      2
#define NVRAM_AUTO_GEN_INTEGER    4

#define fprintf_blank_line(x) fprintf (x,"\n")

static FILE* logOfSize;
static FILE* logOfTools;
#ifdef __NVRAM_PSEUDO_MERGE__
static FILE* logOfSize_Package;
#endif

/* used to package samll lid */
#ifdef __NVRAM_PSEUDO_MERGE__
static int nvram_auto_package_num;
static int nvram_auto_pack_file_offset = NVRAM_FILE_HEAD_SIZE;
#endif

static int nvram_restore_cache_system[NVRAM_APP_TOTAL][NVRAM_SYS_CACHE_MAX];
static int nvram_restore_system_idx[NVRAM_APP_TOTAL];
static char **nvram_restore_lid_enum_array;
static char **nvram_restore_lid_description_point;
static int nvram_max_length_lid_str;
static int nvram_total_num_restore_lid;
static char base_path[NVRAM_AUTO_GEN_MAX_PATH_LEN];



/*****************************************************************************
* FUNCTION
*   nvram_gen_check_sys_cache
* DESCRIPTION
*   output system cache default value to nvram_mmi_cust_pack.h
* PARAMETERS
*
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_check_sys_cache(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_idx;
    int byte_idx;
    int bit_idx;
    kal_uint8 *data = &(nvram_sys_cache[NVRAM_SYS_CACHE_BEGIN-1].value1);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (loop_idx = NVRAM_SYS_CACHE_BEGIN; loop_idx < NVRAM_SYS_CACHE_MAX; loop_idx++)
    {
        if(nvram_sys_cache[loop_idx].id != loop_idx+1)
        {
            fprintf(stderr, "ERROR: please check nvram_data_items.h and nvram_data_items.c: # sys cache enum (%d) and # sys cache entry must sync.", loop_idx);
            exit(3);
        }

        byte_idx = loop_idx / 8;
        bit_idx = loop_idx % 8;
        if (nvram_sys_cache[loop_idx].restore)
        {
            data[byte_idx] |= (0x01 << bit_idx);
            nvram_restore_cache_system[nvram_sys_cache[loop_idx].app_id][nvram_restore_system_idx[nvram_sys_cache[loop_idx].app_id]] = loop_idx;
            nvram_restore_system_idx[nvram_sys_cache[loop_idx].app_id]++;
        }
    }
}


void nvram_gen_sys_cache_default(FILE *fh_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_idx;
    int loop_value_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* step 1: generate restore mark */
    fprintf(fh_file, "kal_uint8 const NVRAM_EF_SYS_CACHE_OCTET_DEFAULT[NVRAM_EF_SYS_CACHE_OCTET_TOTAL * NVRAM_EF_SYS_CACHE_OCTET_SIZE] =\n");
    fprintf(fh_file, "{\n");

    /* step 2: generate default value */
    for (loop_idx = NVRAM_SYS_CACHE_BEGIN; loop_idx < NVRAM_SYS_CACHE_MAX; loop_idx++)
    {
        for (loop_value_idx = 0; loop_value_idx < sizeof(double); loop_value_idx++)
        {
            fprintf(fh_file,"    0x%02X, ",
                    *(kal_uint8 *)(&(nvram_sys_cache[loop_idx - 1].value1) + loop_value_idx));
        }
        fprintf(fh_file, "\n");
    }

    /* step 3: generate last */
    for (loop_value_idx = 0; loop_value_idx < sizeof(double) - 1; loop_value_idx++)
    {
        fprintf(fh_file, "    0x%02X, ",
                *(&(nvram_sys_cache[NVRAM_SYS_CACHE_MAX - 1].value1) + loop_value_idx));
    }

    fprintf(fh_file, "    0x%02X ", nvram_sys_cache[NVRAM_SYS_CACHE_MAX - 1].value8);

    fprintf(fh_file, "\n");

    fprintf(fh_file, "};\n");
}


void nvram_gen_sys_cache_res_func(FILE *fh_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int loop_app_idx;
    int loop_app_cache_idx;
    int loop_value_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fprintf(fh_file, NVRAM_RESTORE_FUNCTION_NAME, "system");

    for (loop_app_idx = 0; loop_app_idx < NVRAM_APP_TOTAL; loop_app_idx++)
    {
        if (nvram_restore_system_idx[loop_app_idx])
        {
            fprintf(fh_file,"        case %s :\n", nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][0]].app_id_str);
        }
        else
        {
            continue;
        }

        for (loop_app_cache_idx = 0; loop_app_cache_idx < nvram_restore_system_idx[loop_app_idx]; loop_app_cache_idx++)
        {
            /*-----------------------------------------------------------
            fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_ID,
                        nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].id_str);

            for (loop_space = 0; loop_space < nvram_max_length_double_id_str - strlen(nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].id_str); loop_space++)
            {
                fprintf(fh_restore_dom_h, " ");
            }

            fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_DESCRIPTION,
                        nvram_mmi_cache_double[nvram_restore_cache_double[loop_app_idx][loop_app_cache_idx]].discription);
            -----------------------------------------------------------*/

            fprintf(fh_file, NVRAM_AUTO_GEN_COMMENT, nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].description);

            for (loop_value_idx = 0; loop_value_idx < sizeof(double); loop_value_idx++)
            {
                fprintf(fh_file,"            buffer[%d * (%s - 1) + %d] = 0x%02X;\n",
                        sizeof(double),
                        nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].id_str,
                        loop_value_idx,
                        *(&(nvram_sys_cache[nvram_restore_cache_system[loop_app_idx][loop_app_cache_idx]].value1) + loop_value_idx));
            }
        }

        fprintf(fh_file,NVRAM_RESTORE_FUNCTION_BREAK);
    }
    fprintf(fh_file, NVRAM_RESTORE_FUNCTION_TAIL, 4);
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_lid_size
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
char s[512];
char indirect_end_symbol[20];

void nvram_gen_ltable_list(void)
{

    typedef enum
    {
      INDIRECT_PROCESS_YET,
      INDIRECT_PROCESS_ING,
      INDIRECT_PROCESS_FINISHED
    }indirect_process_enum;
    
    FILE* tbl_list = NULL;
    FILE* map_file = NULL;
	char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    indirect_process_enum process_indirect_init = INDIRECT_PROCESS_YET;


    sprintf(pathname,"%s/nvram_auto_gen/nvram_ltable_list.h",base_path);
    printf("%s\n", pathname);
    tbl_list= fopen(pathname,"w+");
    if (tbl_list == NULL)
    {
        fprintf(stderr, "error: %s - nvram_ltable_list.h\n", strerror(errno));
        return;
    }

    sprintf(pathname,"%s/nvram_auto_gen/debug/nvram_auto_gen.map",base_path);
    printf("%s\n", pathname);
    map_file = fopen(pathname,"r");

    if (map_file == NULL)
    {
        fprintf(stderr, "error: %s - nvram_auto_gen.map\n", strerror(errno));
        return;
    }



    while (fgets(s, 512, map_file) > 0)
    {
        char *ptr;
        char *brk;
        s[511] = 0;
        
        brk = strchr(s, '\n');

        if (brk)
            *brk = 0;

        if (process_indirect_init == INDIRECT_PROCESS_YET)
        {
            if ((ptr = strstr(s, "logical_data_item_table_")))
            {
        
                fprintf(tbl_list, "#pragma comment(linker, \"/INCLUDE:_%s\")\n", ptr);
            }
        
            if (strstr(s, "*(_indirect_init)"))
            {
                process_indirect_init = INDIRECT_PROCESS_ING;
                fgets(s, 512, map_file); /* skip one line */
                s[511] = 0;
        
                if (strstr(s, indirect_end_symbol))
                {
                    process_indirect_init = INDIRECT_PROCESS_FINISHED;
                    break;
                }
            }
        }
    else if (process_indirect_init == INDIRECT_PROCESS_ING)
    {
    
        if (strstr(s, indirect_end_symbol))
        {
            process_indirect_init = INDIRECT_PROCESS_FINISHED;
            break;
        }
    
        ptr = strrchr(s, ' ') + 1;
        printf("%s\n", ptr);
        
        if (!strstr(ptr, "./build/"))
        {
            fprintf(tbl_list, "#pragma comment(linker, \"/INCLUDE:_%s\")\n", ptr);                
        }
    }

    }

    fclose(map_file);	
    fclose(tbl_list);

}
void nvram_gen_lid_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __NVRAM_PSEUDO_MERGE__
    kal_uint16 fake_lid;
    int sum = 0;
#endif
    kal_uint32 i,j;
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
    /* Gen information for tools */
	sprintf(pathname, "%s/nvram_auto_gen/~nvram_lid_information.log", base_path);
    logOfTools = fopen(pathname,"w+");
    if (logOfTools == NULL)
    {
        fprintf(stderr, "error: %s - ~nvram_lid_information.log\n", strerror(errno));
    }
    else
    {
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
        fprintf(logOfTools,"%4s    %45s    %10s    %10s    %40s  %10s  %10s\n","LID","LID(String)","Filename","Verno","Description", "Category", "Attribute");
        fprintf(logOfTools,"----------------------------------------------------------------------------------------------------------------------------------------------\n");
    } /* end for tools */

    sprintf(pathname, "%s/nvram_auto_gen/~nvram_lid_size.log", base_path);
    logOfSize = fopen(pathname,"w+");
    if (logOfSize == NULL)
    {
        fprintf(stderr, "error: %s - ~nvram_lid_size.log\n", strerror(errno));
    }
    else
    {
        kal_uint32 onefilesize = 0;
        nvram_ltable_entry_struct *ldi;

        fprintf(logOfSize, "--------------------------------------------------------------------------\n");

        #ifdef __NVRAM_PSEUDO_MERGE__
		sprintf(pathname, "%s/nvram_auto_gen/nvram_lid_size_merge.log", base_path);
        logOfSize_Package = fopen(pathname,"w+");
        if (logOfSize_Package == NULL)
        {
            fprintf(stderr, "error: %s - nvram_lid_size_merge.log\n", strerror(errno));
        }
        else
        {
            fprintf(logOfSize_Package, "%4s   %10s    %10s    %10s    %10s    %10s    %10s\n",
                    "ldi->LID", "fileprefix", "onefilesize", "oneLIDsize", "single_num", "single_offset", "file_size");
        }

        #endif

        nvram_restore_lid_enum_array = malloc(sizeof(char *) * nvram_gen_total_lid);
        nvram_restore_lid_description_point = malloc(sizeof(char *) * nvram_gen_total_lid);

        
        for (i = 0;i < nvram_gen_total_lid; i++)
        {
            ldi = &logical_data_item_table[i];

            if (ldi == NULL ||
                (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
            {
                continue;   /* invalid LID */
            }
        #ifdef __NVRAM_PSEUDO_MERGE__
            sum ++;
        #endif
            /* Output data item size */
            onefilesize = (ldi->size + 2) * ldi->total_records;
            if(onefilesize)
            {
            /* Record data item will be restored (begin) */
                if (ldi->attr & NVRAM_ATTR_FACTORY_RESET)
                {
                    if (strlen(ldi->str_LID) > nvram_max_length_lid_str)
                    {
                        nvram_max_length_lid_str = strlen(ldi->str_LID);
                    }
                    nvram_restore_lid_enum_array[nvram_total_num_restore_lid] = ldi->str_LID;
                    nvram_restore_lid_description_point[nvram_total_num_restore_lid] = ldi->description;
                    nvram_total_num_restore_lid++;
                }
            /* Record data item will be restored (end) */
            #ifdef __NVRAM_PSEUDO_MERGE__
                if (NVRAM_IS_ATTR_PACKAGE(ldi->attr))
                {
                    /* Gen information for tools */
                    if (logOfTools)
                    {
                        fprintf(logOfTools,"%4d    %45s    %10s    %10s    %40s      0x%04x      0x%04x\n",ldi->LID,ldi->str_LID,"PACK","LID",ldi->description, ldi->category, ldi->attr);
                    }
                    /* end */

                    nvram_auto_package_num++;
                    {
                        fprintf(logOfSize_Package, "%40s", ldi->description);
                        ldi->description = nvram_auto_pack_file_offset;
                        nvram_auto_pack_file_offset += onefilesize;
                        fprintf(logOfSize_Package, "%4d    %10s    %10d    %10d    %10d    %10d    %10d\n",
                                ldi->LID, ldi->fileprefix, onefilesize, ldi->size, nvram_auto_package_num, (kal_int32)(ldi->description), nvram_auto_pack_file_offset);
                    }

                    fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, 0, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");

                    continue;   /* already calculate in package file */
                }
            #endif
                fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, onefilesize, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");

                if (NVRAM_IS_ATTR_MULTIPLE(ldi->attr))
                {
                    fprintf(logOfSize, "%4d%10d%60s%20s\n", ldi->LID, onefilesize, ldi->str_LID, NVRAM_IS_CATEGORY_CUSTPACK(ldi->category)?"CUSTPACK":"");
                }

                /* Gen information for tools */
                if (logOfTools)
                {
                    fprintf(logOfTools,"%4d    %45s    %10s    %10s    %40s      0x%04x      0x%04x\n",ldi->LID,ldi->str_LID,ldi->fileprefix,ldi->fileverno,ldi->description, ldi->category, ldi->attr);
                }
                /* end */
            }
        }

    #ifdef __NVRAM_VENDOR_SUPPORT__
        fprintf(logOfSize,
                "%4d%10d%60s\n",
                nvram_gen_total_lid,
                nvram_vendor_reserve_size,
                "NVRAM_EF_VENDOR_REMAIN_SPACE_LID"
                );
    #endif /* __NVRAM_VENDOR_SUPPORT__ */

    #ifdef __NVRAM_PSEUDO_MERGE__
        fake_lid = nvram_gen_total_lid;
    #ifdef __NVRAM_VENDOR_SUPPORT__
        fake_lid += 1;
    #endif
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid, nvram_auto_pack_file_offset, "Package file size");
        /* LID information nvram_auto_package_num */
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 1, nvram_auto_package_num * (sizeof(LID_info_struct) + 2), "Info file A");
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 2, nvram_auto_package_num * (sizeof(LID_info_struct) + 2), "Info file B");
        /* extra cluster is need, for temp file, package file, truncate file */
        fprintf(logOfSize, "%4d%10d%40s\n", fake_lid + 3, 3 * 512,"Extra size");
       /***
        * fprintf(logOfSize,"sum: %4d   nvram_auto_package_num = %4d\n",sum,nvram_auto_package_num);
        */
    #endif /* __NVRAM_PSEUDO_MERGE__ */

        fprintf(logOfSize, "--------------------------------------------------------------------------\n");

		#ifdef __NVRAM_COMPRESS_SUPPORT__
		fprintf(logOfSize, "NVRAM_COMPRESS=1\n");
		#else
		fprintf(logOfSize, "NVRAM_COMPRESS=0\n");
		#endif

        fclose(logOfSize);
    #ifdef __NVRAM_PSEUDO_MERGE__
        fclose(logOfSize_Package);
    #endif
    }

    /* Gen information for tools */
    if (logOfTools)
    {
        fprintf(logOfTools,"--------------------------------------------------------------------------------------------\n");
        fclose(logOfTools);
    }
    /* end */

    for (i = 0;i < nvram_gen_total_lid; i++)
    {
        nvram_ltable_entry_struct *ldi1, *ldi2;

        ldi1 = &logical_data_item_table[i];

        if (ldi1 == NULL || (ldi1->LID == 0 && ldi1->size == 0 && ldi1->total_records == 0))
        {
            continue;   /* invalid LID */
        }

        if (strcasecmp(ldi1->fileprefix, "") == 0)
        {
            fprintf(stderr, "error: fileprefix of %s = %d cannot be NULL!\n", ldi1->str_LID, ldi1->LID);
            exit(NVRAM_EXIT_CODE_ERROR);
        }

        for (j = i + 1 ;j < nvram_gen_total_lid; j++)
        {
            ldi2 = &logical_data_item_table[j];

            if (ldi2 == NULL || (ldi2->LID == 0 && ldi2->size == 0 && ldi2->total_records == 0))
            {
                continue;   /* invalid LID */
            }

            if (strcasecmp(ldi1->fileprefix, ldi2->fileprefix) == 0 &&
                strcasecmp(ldi1->fileverno, ldi2->fileverno) == 0)
            {
                fprintf(stderr, "error: duplicated fileprefix and fileverno %s %s of %s and %s\n", ldi1->fileprefix, ldi1->fileverno, ldi1->str_LID, ldi2->str_LID);
                exit(NVRAM_EXIT_CODE_ERROR);
            }
        }
   
    }

    
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_statistic
* DESCRIPTION
*  Output nvram_lid_statistic.h
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_statistic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32   error = 0;
    FILE* outputHeader;
    kal_uint8    sys_str[2048];
    char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    char pathnameOrg[NVRAM_AUTO_GEN_MAX_PATH_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	sprintf(pathname, "%s/nvram_auto_gen/nvram_lid_statistics_bak.h", base_path);
    sprintf(pathnameOrg, "%s/nvram_auto_gen/nvram_lid_statistics.h", base_path);
    outputHeader = fopen(pathname,"w+");
    if (outputHeader == NULL)
    {
        fprintf(stderr, "error: %s - %s\n",strerror(errno) ,pathname);
    }
    else
    {

        fprintf(outputHeader, COPYRIGHTS_HEADER, "nvram_lid_statistics_bak.h");

        fprintf(outputHeader, "#ifndef NVRAM_LID_STATISTIC_H\n#define NVRAM_LID_STATISTIC_H\n");

    #ifdef __NVRAM_OTP__
        fprintf(outputHeader, "#define NVRAM_OTP_SIZE    %d\n", otp_size_to_verify);
        fprintf(outputHeader, "#define NVRAM_OTP_TOTAL   %d\n", otp_total_to_verify);
    #endif

        fprintf(outputHeader, "#define NVRAM_CUSTPACK_TOTAL  %d\n", custpack_total_to_verify);

        fprintf(outputHeader, "#define NVRAM_SECUPACK_SIZE  %d\n", secupack_size_to_verify);
        fprintf(outputHeader, "#define NVRAM_SECUPACK_TOTAL  %d\n", secupack_total_to_verify);

    #if defined(__NVRAM_SECURE_DATA_STORAGE__)
        fprintf(outputHeader, "#define NVRAM_SDS_TOTAL  %d\n", sds_total_to_verify);
        fprintf(outputHeader, "#define NVRAM_SDS_SIZE  %d\n", sds_size_to_verify);
    #endif

    #ifdef __NVRAM_PSEUDO_MERGE__
        fprintf_blank_line(outputHeader);
        fprintf(outputHeader, "#ifdef __NVRAM_PSEUDO_MERGE__\n");
        fprintf(outputHeader, "#define NVRAM_PACKAGE_LID_NUM     %d\n", nvram_auto_package_num);
        fprintf(outputHeader, "#define NVRAM_PACKAGE_LID_SIZE    %d\n", nvram_auto_pack_file_offset);
        fprintf(outputHeader, "#endif /* __NVRAM_PSEUDO_MERGE__ */\n");
    #endif

        fprintf(outputHeader,"\n#endif /* NVRAM_LID_STATISTIC_H */\n\n");
        fclose(outputHeader);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif        
    }
}


/*****************************************************************************
* FUNCTION
*  nvram_gen_array
* DESCRIPTION
*  Output formatted arrays to custom_nvram_secro, i.e. 16 bytes/line
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_array(FILE* handle, kal_char* indent, kal_uint8 type, kal_uint32 max_size, kal_uint8 *array, kal_bool calc_cksum, kal_bool last_block)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 i;
    kal_uint8 byte_chksum[2] = {0};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* We only support checksum on NVRAM_AUTO_GEN_BYTE */

    for (i = 0; i < max_size; i += type)
    {
        if (calc_cksum && type == NVRAM_AUTO_GEN_BYTE)
        {
            if (i & 0x1)
            {
                byte_chksum[1] += array[i];
            }
            else
            {
                byte_chksum[0] += array[i];
            }
        }

        if (i % 16 == 0)
        {
            fprintf(handle, "\n%s", indent);
        }

        switch (type)
        {
            case NVRAM_AUTO_GEN_INTEGER:
                fprintf(handle, "0x%02X%02X%02X%02X", array[i + 3], array[i + 2], array[i + 1], array[i]);
                break;
            case NVRAM_AUTO_GEN_SHORT:
                fprintf(handle, "0x%02X%02X", array[i + 1], array[i]);
                break;
            case NVRAM_AUTO_GEN_BYTE:
            default:
                fprintf(handle, "0x%02X", array[i]);
                break;
        }

        if (i == max_size - type)
        {
            if (calc_cksum && type == NVRAM_AUTO_GEN_BYTE)
                fprintf(handle, ",\n%s/* check sum */\n%s0x%02x, 0x%02x", indent, indent, byte_chksum[0], byte_chksum[1]);

            if (!last_block)
            {
                fprintf(handle, ", ");
            }
        }
        else
        {
            fprintf(handle, ", ");
        }
    }


}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_secro
* DESCRIPTION
*  Output custom_nvram_secro.c.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_secro(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i = 0;
    FILE* outputHeader;
    FILE* outputHeader2;
	char pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	sprintf(pathname, "%s/nvram_auto_gen/custom_nvram_secro.c", base_path);
    outputHeader = fopen(pathname,"w+");
    sprintf(pathname, "%s/nvram_auto_gen/custom_nvram_secro_tbl.c", base_path);    
    outputHeader2 = fopen(pathname,"w+");
    
    if ((outputHeader == NULL) || (outputHeader2 == NULL))    {
        fprintf(stderr, "error: %s - custom_nvram_secro.c\n", strerror(errno));
    }
    else
    {
        fprintf(outputHeader, COPYRIGHTS_HEADER, "custom_nvram_secro.c");

        fprintf(outputHeader, "#if !defined(NVRAM_NOT_PRESENT)");

        fprintf(outputHeader, "\n#include \"kal_general_types.h\"");

        fprintf(outputHeader, "\n#ifdef __SECURE_RO_ENABLE__");

        fprintf(outputHeader, "\n#include \"custom_nvram_sec.h\"");

        // GCC dose not recognize pragma, and we have to use attribute
        //fprintf(outputHeader, "\n#pragma arm section rodata = \"SECURE_RO\"");
        fprintf(outputHeader, "\n__attribute__ ((section (\"SECURE_RO\")))");
        fprintf(outputHeader, "\nconst SEC_RO_ST g_SEC_RO =");
        fprintf(outputHeader, "\n{");
        fprintf(outputHeader, "\n    /* SEC_RO ver */");
        fprintf(outputHeader, "\n    SEC_RO_STRUCT_VER,");

        fprintf(outputHeader, "\n    /* custom secret key */");

        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, NVRAM_SECRET_KEY_SIZE, custom_secret_key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    },");

        fprintf(outputHeader, "\n    /* custom secret key len */");
        fprintf(outputHeader, "\n    NVRAM_SECRET_KEY_SIZE,");

        fprintf(outputHeader, "\n    /* NVRAM Secure Parameters */");
        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, SEC_RO_PARA_TOTAL, NVRAM_SECURE_PARA, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    },");

        fprintf(outputHeader, "\n    /* NVRAM SecuPack data */");

        fprintf(outputHeader, "\n    {");



        i = 0;
        secupack_idx = 0;
        fprintf(outputHeader2, "#if defined(NVRAM_SEC_C_ONLY)");
        fprintf(outputHeader2, "\nconst nvram_lid_enum secupack_nvram_lid_tbl[%d] = ", secupack_total_to_verify);
        fprintf(outputHeader2, "\n{");

        while (i < nvram_gen_total_lid)
        {
            nvram_ltable_entry_struct *ldi = &logical_data_item_table[i];
            if (ldi && ldi->category & NVRAM_CATEGORY_SECUPACK)
            {
                fprintf(outputHeader2, "\n   %d,", ldi->LID);

            #ifndef __NVRAM_PSEUDO_MERGE__
                if (secupack_idx != 0)
                    fprintf(outputHeader, "\n", ldi->str_LID);

                fprintf(outputHeader, "\n        /* %s */", ldi->str_LID);
            #endif
                nvram_gen_array(outputHeader,
                    "        ",
                    NVRAM_AUTO_GEN_BYTE,
                    ldi->size * (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT? ldi->total_records : 1),
                    (kal_uint8 *)ldi->default_value,
                    KAL_TRUE,
                    ((secupack_idx + 1) == secupack_total_to_verify));

                secupack_idx++;
            }
            i++;
        }


        fprintf(outputHeader2, "\n};");
        fprintf(outputHeader2, "\n#endif");
        fclose(outputHeader2);
    
        fprintf(outputHeader, "\n    },");

#ifdef __SECURE_USB_DOWNLOAD__
        fprintf(outputHeader, "\n#ifdef __SECURE_USB_DOWNLOAD__");
        fprintf(outputHeader, "\n    SEC_RO_MAGIC_HEAD_VALUE,");
        fprintf(outputHeader, "\n    /* custom symmetric key */");

        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, NVRAM_SECRET_KEY_MAX_SIZE, (kal_uint8 *)&custom_symmetric_key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    },");

        fprintf(outputHeader, "\n    /* custom symmetric key len */");
        fprintf(outputHeader, "\n    NVRAM_SECRET_KEY_MAX_SIZE,");
        fprintf(outputHeader, "\n    /* custom asymmetric key */");

        fprintf(outputHeader, "\n    {");
        fprintf(outputHeader, "\n        %d,%d,0x%04X,%d,", custom_asymmetric_key.nELen, custom_asymmetric_key.nNLen, custom_asymmetric_key.MCoeff, custom_asymmetric_key.nCutLength);
        fprintf(outputHeader, "\n        {");
        nvram_gen_array(outputHeader, "            ", NVRAM_AUTO_GEN_SHORT, custom_asymmetric_key.nELen << 1, (kal_uint8 *)&custom_asymmetric_key.E_Key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n        },");
        fprintf(outputHeader, "\n        {");
        nvram_gen_array(outputHeader, "            ", NVRAM_AUTO_GEN_SHORT, custom_asymmetric_key.nNLen << 1, (kal_uint8 *)&custom_asymmetric_key.N_Key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n        },");
        fprintf(outputHeader, "\n    },");

        fprintf(outputHeader, "\n    /* custom asymmetric key len */");
        fprintf(outputHeader, "\n    NVRAM_ASYMMETRIC_KEY_MAX_SIZE,");
        fprintf(outputHeader, "\n    SEC_RO_MAGIC_TAIL_VALUE,");
        fprintf(outputHeader, "\n#endif /* __SECURE_USB_DOWNLOAD__ */");
#endif /* __SECURE_USB_DOWNLOAD__ */

        fprintf(outputHeader, "\n    {");
        fprintf(outputHeader, "\n        ");
        for (i = NVRAM_MSP_ALIGNMENT - 1; i >=0; i--)
        {
            if (i != 0)
            {
                fprintf(outputHeader, "0x00,");
            }
            else
            {
                fprintf(outputHeader, "0x00");
            }
        }
        fprintf(outputHeader, "\n    }");


        fprintf(outputHeader, "\n};");
        // GCC dose not recognize pragma, and we have to use attribute
        //fprintf(outputHeader, "\n#pragma arm section rodata");

        fprintf(outputHeader, "\n#else  /* __SECURE_RO_ENABLE__ */");

        fprintf(outputHeader, "\nconst kal_uint8 NVRAM_CUSTOM_KEY[] = ");

        fprintf(outputHeader, "\n    {");
        nvram_gen_array(outputHeader, "        ", NVRAM_AUTO_GEN_BYTE, NVRAM_SECRET_KEY_SIZE, custom_secret_key, KAL_FALSE, KAL_TRUE);
        fprintf(outputHeader, "\n    };");

        fprintf(outputHeader, "\n#if defined(__RES_PROT__)");
        fprintf(outputHeader, "\n__attribute__((section(\"PROTECTED_RES_RW\")))");
        fprintf(outputHeader, "\n#endif");

        fprintf(outputHeader, "\nconst kal_uint8 NVRAM_SECUPACK_DEFAULT[] = ");

        fprintf(outputHeader, "\n    {");

        i = 0;
        secupack_idx = 0;
        while (i < nvram_gen_total_lid)
        {
            nvram_ltable_entry_struct *ldi = &logical_data_item_table[i];
            if (ldi && ldi->category & NVRAM_CATEGORY_SECUPACK)
            {
            #ifndef __NVRAM_PSEUDO_MERGE__
                if (secupack_idx != 0)
                    fprintf(outputHeader, "\n", ldi->str_LID);

                fprintf(outputHeader, "\n        /* %s */", ldi->str_LID);
            #endif
                nvram_gen_array(outputHeader,
                    "        ",
                    NVRAM_AUTO_GEN_BYTE,
                    ldi->size * (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT? ldi->total_records : 1),
                    (kal_uint8 *)ldi->default_value,
                    KAL_TRUE,
                    (secupack_idx + 1 == secupack_total_to_verify));
                secupack_idx++;
            }
            i++;
        }


        /* Fake data for special case */
        if (secupack_total_to_verify == 0)
        {
            fprintf(outputHeader, "\n        0x00, 0x00");
        }

        fprintf(outputHeader, "\n    };");

        fprintf(outputHeader, "\n#endif /* __SECURE_RO_ENABLE__ */");


        fprintf(outputHeader, "\nkal_uint32 secupack_total_to_verify = %d;", secupack_total_to_verify);
        fprintf(outputHeader, "\n#endif /* NVRAM_NOT_PRESENT */");
        fclose(outputHeader);
    }
}
#endif /* __VENDOR_RELEASE__ */

/*****************************************************************************
* FUNCTION
*   nvram_gen_mmi_cache
* DESCRIPTION
*   output restore head file to nvram_restore_headfile.h
* PARAMETERS
*   project_name    [IN]
*   broad_ver       [IN]
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_create_file(FILE **file_handle, char *file_path, char *file_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int  mode_result;
    char file_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(file_pathname, "%s/%s", file_path, file_name);

    mode_result = access(file_pathname, 0);

    if (mode_result == 0)
    {
        /* exists,but check if it can be written. */
        mode_result = access(file_pathname, 2);
        if (mode_result != 0)
        {
            fprintf(stderr, "error: %s exists,but it cannot be written.\n", file_name);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
    }
    else
    {
        /* file not exist*/
        mode_result = access(file_path, 2);
        if (mode_result != 0)
        {
            fprintf(stderr, "error: cannot create file in folder: %s\n", file_path);
            exit(NVRAM_EXIT_CODE_ERROR);
        }
    }

    *file_handle = fopen(file_pathname, "w+");
    if (*file_handle == NULL)
    {
        fprintf(stderr, "error: cannot write to %s in folder: %s(%s)\n", file_name, file_path, strerror(errno));
        exit(NVRAM_EXIT_CODE_ERROR);
    }
    else
    {
         printf("Create %x:%s successfully!\n", *file_handle, file_pathname);   
    }
    return;
}

void nvram_gen_close_file(FILE **file_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    fclose(*file_handle);
}
/*****************************************************************************
* FUNCTION
*   nvram_gen_restore_function
* DESCRIPTION
*   output restore function to nvram_user_restore_factory.c
* PARAMETERS
*   project_name    [IN]
*   broad_ver       [IN]
* RETURNS
*   none
*****************************************************************************/
void nvram_gen_restore_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *fh_restore_factory_c;
    FILE *fh_restore_dom_h;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    int  loop_app_idx;
    int  loop_space;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_restore.c");
    nvram_gen_create_file(&fh_restore_factory_c,base_path,output_pathname);

    sprintf(output_pathname,"nvram_auto_gen/nvram_restore_dom.h");
    nvram_gen_create_file(&fh_restore_dom_h,base_path,output_pathname);

    /* generate head file */
    fprintf(fh_restore_factory_c, COPYRIGHTS_HEADER, "nvram_user_restore_factory.h");

    fprintf_blank_line(fh_restore_factory_c);

    fprintf(fh_restore_factory_c, "#ifndef NVRAM_NOT_PRESENT\n");
    fprintf(fh_restore_factory_c, "#include \"kal_general_types.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"nvram_enums.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"custom_nvram_config.h\"\n");
    fprintf(fh_restore_factory_c, "#include \"nvram_data_items.h\"\n");


    /*
     * Begin deal with system cache
     */
    nvram_gen_check_sys_cache();
    nvram_gen_sys_cache_default(fh_restore_factory_c);
    nvram_gen_sys_cache_res_func(fh_restore_factory_c);

    /* Dom: data item (begin) */
    fprintf(fh_restore_dom_h, R_F_DOM_COMMENT, "LID");
    fprintf(fh_restore_dom_h, R_F_DOM_ENUM_BEGIN);

    for (loop_app_idx = 0; loop_app_idx < nvram_total_num_restore_lid; loop_app_idx++)
    {
        fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_ID, nvram_restore_lid_enum_array[loop_app_idx]);
        for (loop_space = 0; loop_space < nvram_max_length_lid_str - strlen(nvram_restore_lid_enum_array[loop_app_idx]); loop_space++)
        {
            fprintf(fh_restore_dom_h, " ");
        }
        fprintf(fh_restore_dom_h, R_F_DOM_CONTENT_DESCRIPTION, nvram_restore_lid_description_point[loop_app_idx]);
    }
    fprintf(fh_restore_dom_h, R_F_DOM_ENUM_END, "LID", "LID");
    /* Dom: data item (begin) */

    /*
     * End deal with system cache
     */

    fprintf(fh_restore_factory_c, "#endif /* NVRAM_NOT_PRESENT */");

    nvram_gen_close_file(&fh_restore_factory_c);
    nvram_gen_close_file(&fh_restore_dom_h);
}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_database_key
* DESCRIPTION
*  This function is used to generate the database key into custom_nvram_database.h
*  After that, codegen will use this file and generate the key into NVRAM database.
*  Metatool will read the key from database also.
*  Please notify codegen owner and metatool owner if you want to change the format.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void nvram_gen_database_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *database_h;
    FILE *fh_restore_dom_h;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_database.h");
    nvram_gen_create_file(&database_h,base_path,output_pathname);

#ifdef __NVRAM_SECRET_DATA__
    fprintf(database_h, "typedef enum \n");
    fprintf(database_h, "{\n");

    for (i = 0 ; i < NVRAM_DATABASE_KEY_SIZE ; i+=8)
    {
        fprintf(database_h, "    NVRAM_DB_KEY%02d_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x_0x%02x = %d,\n",
                            (i >> 3) + 1,
                            custom_secret_data.m_custom_database_key[i],
                            custom_secret_data.m_custom_database_key[i+1],
                            custom_secret_data.m_custom_database_key[i+2],
                            custom_secret_data.m_custom_database_key[i+3],
                            custom_secret_data.m_custom_database_key[i+4],
                            custom_secret_data.m_custom_database_key[i+5],
                            custom_secret_data.m_custom_database_key[i+6],
                            custom_secret_data.m_custom_database_key[i+7],
                            i >> 3);
    }

    fprintf(database_h, "    NVRAM_DB_KEY_LAST_Enum_Idx\n");
    fprintf(database_h, "} NVRAM_DB_Key_enum_t;");
#endif

    nvram_gen_close_file(&database_h);
}
#endif  /* __VENDOR_RELEASE__ */

/*****************************************************************************
* FUNCTION
*   nvram_gen_custpack_table
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void nvram_gen_custpack_table(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *output, *output2;
    char output_path[NVRAM_AUTO_GEN_MAX_PATH_LEN], output_path2[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    int i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_path, "%s/nvram_auto_gen/nvram_custpack_table.c", base_path);
    sprintf(output_path2, "%s/nvram_auto_gen/nvram_custpack_table_lid.c", base_path);

    if(!(output = fopen(output_path, "w+")))
    {
        exit(NVRAM_EXIT_CODE_ERROR);
    }

    if(!(output2 = fopen(output_path2, "w+")))
    {
        exit(NVRAM_EXIT_CODE_ERROR);
    }

    fprintf(output,"#if defined(NVRAM_INTERNAL_USE) && !defined(NVRAM_NOT_PRESENT)\n");
    fprintf(output,"/********************************************************\n");
    fprintf(output," *  This file is generated automatically by nvram_auto_gen\n");
    fprintf(output," *  Please do not modify it here manually \n");
    fprintf(output," ***********************************************************/\n");

    fprintf(output2,"#if defined(NVRAM_LTABLE_C_ONLY)\n");
/*
    for (i = NVRAM_EF_START, j = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL ||
            (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (NVRAM_IS_CATEGORY_CUSTPACK(ldi->category))
        {
            j++;
            fprintf(output, "extern kal_uint8 *%s;\n", ldi->str_default_value);
        }
    }

    fprintf(output,"\n");    
*/
    fprintf(output, "const custpack_nvram_header custpack_nvram_ptr = \n");
    fprintf(output2, "const nvram_custpack_lid_tbl_struct custpack_nvram_lid_tbl = \n");

    fprintf(output, "{\n");         fprintf(output2, "{\n");
    fprintf(output, "    0,\n");    fprintf(output2, "    0,\n");
    fprintf(output, "    {\n");     fprintf(output2, "    {\n");

    for (i = NVRAM_EF_START, j = 0; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL ||
            (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        if (NVRAM_IS_CATEGORY_CUSTPACK(ldi->category))
        {
            j++;
            fprintf(output, "        %s", ldi->str_default_value);
            fprintf(output2, "        %d", ldi->LID);

            if (j != custpack_total_to_verify)
            {
                fprintf(output,",");    fprintf(output2,",");
            }
            fprintf(output,"\n");       fprintf(output2,"\n");
        }
    }


    fprintf(output, "    }\n");         fprintf(output2, "    }\n");
    fprintf(output, "};\n");            fprintf(output2, "};\n");
    fprintf(output, "#endif /* NVRAM_INTERNAL_USE && NVRAM_NOT_PRESENT */\n\n");
    fprintf(output2, "#endif\n\n");

    fclose(output);        fclose(output2);
}

/*****************************************************************************
* FUNCTION
*  nvram_gen_cat_xml
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_cat_xml(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *cat_xml_file;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    kal_int32 i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/custom_nvram_lid_cat.xml");
    nvram_gen_create_file(&cat_xml_file,base_path,output_pathname);

    fprintf(cat_xml_file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");

    fprintf(cat_xml_file, "<APP>\n");

    for (i = NVRAM_EF_START; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }

        fprintf(cat_xml_file, "    <NVRAMITEM id=\"%s\"", ldi->str_LID);
        fprintf(cat_xml_file, " prefix=\"%s\"", ldi->fileprefix);
        fprintf(cat_xml_file, " version=\"%s\"", ldi->fileverno);
        fprintf(cat_xml_file, " record_size=\"%d\"", ldi->size);
        fprintf(cat_xml_file, " total_record=\"%d\">\n", ldi->total_records);

        if (ldi->default_value == NVRAM_EF_ZERO_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"0x00\"></DEFAULT_VALUE>\n");
        }
        else if (ldi->default_value == NVRAM_EF_FF_DEFAULT)
        {
            fprintf(cat_xml_file, "        <DEFAULT_VALUE defaultByteFill=\"0xFF\"></DEFAULT_VALUE>\n");
        }
        else
        {
            kal_uint32 default_value_size;


            if (ldi->attr & NVRAM_ATTR_MULTI_DEFAULT)
            {
                fprintf(cat_xml_file, "        <DEFAULT_VALUE isMultiple=\"TRUE\"> \n");
                default_value_size = ldi->size * ldi->total_records;
            }
            else
            {
                fprintf(cat_xml_file, "        <DEFAULT_VALUE> \n");
                default_value_size = ldi->size;
            }

            for ( j = 0 ; j < default_value_size ; j++)
            {
                if (j == 0)
                {
                    fprintf(cat_xml_file, "            [0x%02X,", ldi->default_value[j]);
                }
                else if (j == (default_value_size - 1))
                {
                    fprintf(cat_xml_file, " 0x%02X]\n        </DEFAULT_VALUE>\n", ldi->default_value[j]);
                }
                else if ((j & 0x0F) == 0x0F)
                {
                    fprintf(cat_xml_file, " 0x%02X,\n", ldi->default_value[j]);
                }
                else if ((j & 0x0F) == 0)
                {
                    fprintf(cat_xml_file, "             0x%02X,", ldi->default_value[j]);
                }
                else
                {
                    fprintf(cat_xml_file, " 0x%02X,", ldi->default_value[j]);
                }
            }
        }

        //fprintf(cat_xml_file, "        <DESCRIPTION> %s </DESCRIPTION>\n", ldi->description);
        fprintf(cat_xml_file, "        <DESCRIPTION> %s </DESCRIPTION>\n", ldi->str_LID);
        fprintf(cat_xml_file, "    </NVRAMITEM>\n");
    }

    fprintf(cat_xml_file, "</APP>\n");

    nvram_gen_close_file(&cat_xml_file);
}

#ifndef __VENDOR_RELEASE__
/*****************************************************************************
* FUNCTION
*  nvram_gen_cat_xml
* DESCRIPTION
*  Output NVRAM LID size Information.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
void nvram_gen_trace(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *trace_file;
    char output_pathname[NVRAM_AUTO_GEN_MAX_PATH_LEN];
    kal_int32 i,j;
    nvram_ltable_entry_struct *ldi;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sprintf(output_pathname, "nvram_auto_gen/nvram_gen_trc.h");
    nvram_gen_create_file(&trace_file,base_path,output_pathname);

    fprintf(trace_file, "typedef enum {\n");
    
    for (i = NVRAM_EF_SYS_LID; i < nvram_gen_total_lid; i++)
    {
        ldi = &logical_data_item_table[i];

        if (ldi == NULL || (ldi->LID == 0 && ldi->size == 0 && ldi->total_records == 0))
        {
            continue;
        }
        else
        {
            fprintf(trace_file, "    _%s = %d,\n", ldi->str_LID, ldi->LID);
        }
    }

    fprintf(trace_file, "    NVRAM_TRC_LID_TOTAL\n}nvram_trc_lid_enum;\n");

    nvram_gen_close_file(&trace_file);
}

#endif    //__VENDOR_RELEASE__
#endif /* NVRAM_NOT_PRESENT */

/*****************************************************************************
* FUNCTION
*  main
* DESCRIPTION
*  main function.
* PARAMETERS
*  None
* RETURNS
*  None
*****************************************************************************/
int main(int argc, char *argv[])
{

#ifndef NVRAM_NOT_PRESENT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (argc > 0)
    {
        
        typedef void (*_indirect_init_func)(void);
        extern unsigned char indirect_init_begin, indirect_init_end;
        extern void fs_quota_init(void);

        kal_uint32 *value = (kal_uint32 *)&indirect_init_begin;
        kal_uint32 i, total = (kal_uint32)(&indirect_init_end - &indirect_init_begin)/sizeof(_indirect_init_func);

        printf("begin:%x, end:%x\n", &indirect_init_begin, &indirect_init_end);
        printf("init_func = %x, total = %d\n", *value, total);
        for (i = 0; i < total; i++)
        {
            _indirect_init_func init_func = (_indirect_init_func)*value + i ;

            printf("init_func[%i] = %x\n", i, init_func);    
            if (init_func)
            {
                init_func();
            }
        }

        printf("argv[1] = %s, argv[2] = %s\n", argv[1], argv[2]);

        if (strcasecmp(argv[1], "MSWin32") == 0)
        {
            sprintf(indirect_end_symbol, "_indirect_init_end = .");
        }
        else
        {
            sprintf(indirect_end_symbol, "indirect_init_end = .");
        }


        printf("nvram_gen_construct_ltable\n");
        nvram_gen_construct_ltable();

        sprintf(base_path, "%s", argv[1]);

    #ifndef __VENDOR_RELEASE__
        printf("nvram_gen_trace\n");
        nvram_gen_trace();
    #endif

        printf("nvram_gen_cat_xml\n");
        nvram_gen_cat_xml();

        printf("nvram_gen_lid_size\n");
        nvram_gen_lid_size();

        printf("nvram_gen_statistic\n");
        nvram_gen_statistic();

        printf("nvram_gen_restore_function\n");
        nvram_gen_restore_function();

    #if !defined(__L1_STANDALONE__) && defined(__MMI_FMI__)
        printf("nvram_gen_custpack_table\n");
        nvram_gen_custpack_table();
    #endif

    #ifndef __VENDOR_RELEASE__
        printf("nvram_gen_secro\n");
        nvram_gen_secro();
    #endif
    
    #if !defined(__VENDOR_RELEASE__) && !defined(__NVRAM_HIDE_DATABASE_KEY__)
        printf("nvram_gen_database_key\n");
        nvram_gen_database_key();
    #endif

        printf("nvram_gen_fs_quota: begin\n");
        nvram_gen_fs_quota(base_path);
        printf("nvram_gen_fs_quota: end\n");

        nvram_gen_ltable_list();
    }
    return 0;
#else
    printf("NVRAM_NOT_PRESENT\n");
    return 0;
#endif
}
