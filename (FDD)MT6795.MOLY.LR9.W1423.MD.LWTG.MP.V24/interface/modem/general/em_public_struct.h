/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

 /*******************************************************************************
 * Filename:
 * ---------
 *   em_struct.h
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Engineer mode public structures.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 * 				HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

 
#ifndef _EM_PUBLIC_STRUCT_H
#define _EM_PUBLIC_STRUCT_H

#include "ps_public_struct.h"
#include "kal_general_types.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#include "ps_em_enum.h"
#include "ps_public_enum.h"

typedef kal_uint32 request_info_type;

typedef enum
{
   /* RR */ 
    /* Begin of RR EM INFO Request enum */
   RR_EM_CELL_SELECT_PARA_INFO = 0, RR_EM_INFO_BEGIN = RR_EM_CELL_SELECT_PARA_INFO,
   RR_EM_CHANNEL_DESCR_INFO,
   RR_EM_CTRL_CHANNEL_DESCR_INFO,
   RR_EM_RACH_CTRL_PARA_INFO,
   RR_EM_LAI_INFO,
   RR_EM_RADIO_LINK_COUNTER_INFO,
   RR_EM_MEASUREMENT_REPORT_INFO,
   /* ZY : Temp solution : Cell allocation list*/
   RR_EM_CA_LIST_INFO,
   /* RR new structure */
   RR_EM_CONTROL_MSG_INFO,
   RR_EM_SI2Q_INFO_STRUCT_INFO, 
   RR_EM_MI_INFO_STRUCT_INFO,
   RR_EM_BLK_INFO,
   RR_EM_TBF_INFO,
   RR_EM_GPRS_GENERAL_INFO,
   /* GAS MM EM INFO */
   RRM_EM_IR_PARAMETER_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_RESELECT_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_3G_NEIGHBOR_MEAS_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_3G_NEIGHBOR_MEAS_INFO_IND_STRUCT_INFO,
   RRM_EM_IR_4G_NEIGHBOR_MEAS_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_4G_NEIGHBOR_MEAS_INFO_IND_STRUCT_INFO,
   RRM_EM_SERV_CELL_POWER_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_3G_NEIGHBOR_CELL_STATUS_IND_STRUCT_INFO,
   RRM_EM_IR_4G_NEIGHBOR_CELL_STATUS_IND_STRUCT_INFO,
   RR_EM_INFO_END = RR_EM_INFO_BEGIN + 49,

   /*End of RR EM INFO Request enum*/
   
   /* CC */ 
   CC_EM_CHANNEL_INFO = 50,
   CC_EM_CALL_INFO,
   
   /* SS */
   SS_EM_INFO,
   
   /* MM */
   MM_EM_INFO,
   /*EM ehancement for RR new structure*/
   MMRR_EM_PLMN_INFO_STRUCT_INFO,
                                        
   /* UEM */                            
   UEM_EM_BATTERY_INFO,
   
   /* gprs em begins */
   GMM_EM_INFO,
//   TCM_EM_EXT_PDP_INFO,
//   TCM_EM_INT_PDP_INFO,
//   TCM_EM_CONTEXT_INFO, //new
//   SNDCP_EM_INFO,
   LLC_EM_INFO,
   /* PPP , removed because of no use*/
   //PPP_EM_INFO,
   SM_EM_INFO,

//#ifdef __VIDEO_CALL_SUPPORT__       
    /* VT EM Display, 2007/11/30 */
    /* VT owner comments VT EM enum is not needed in WR8 */
    //VT_EM_CALL_STATE_INFO = 50, VT_EM_BEGIN = VT_EM_CALL_STATE_INFO,/* vt_em_call_state_choice */
    //VT_EM_MASTER_SLAVE_STATUS_INFO,     /* vt_em_master_slave_status_choice */
    //VT_EM_RETRANSMISSION_PROTOCOL_INFO, /* vt_em_retransmission_protocol_choice */
    //VT_EM_INCOMING_AUDIO_CHANNEL_INFO,  /* vt_em_audio_channel_info_struct */
    //VT_EM_OUTGOING_AUDIO_CHANNEL_INFO,  /* vt_em_audio_channel_info_struct */
    //VT_EM_INCOMING_VIDEO_CHANNEL_INFO,  /* vt_em_video_channel_info_struct */
    //VT_EM_OUTGOING_VIDEO_CHANNEL_INFO,  /* vt_em_video_channel_info_struct */
    //VT_EM_ADM_MEM_MAX_USED_INFO,        /* kal_uint32 */
    //VT_EM_STATISTIC_INFO,               /* vt_em_statistic_info_struct */
    //VT_EM_ROUND_TRIP_DELAY_INFO,        /* kal_uint32 */
    //VT_EM_INCOMING_XSRP_INFO,           /* vt_em_incoming_xSRP */
    //VT_EM_OUTGOING_XSRP_INFO,           /* vt_em_outgoing_xSRP */
	//VT_EM_END = VT_EM_OUTGOING_XSRP_INFO,
//#endif

//#ifdef __UMTS_RAT__          //For MAUI, MONZA2G exclude 3G
   /**
    * Gibran 20061228
    * UAS MEME/CSCE measuremnt and cell status structure
    */
   EM_URR_3G_GENERAL_STATUS_IND = 70, URR_EM_INFO_BEGIN = EM_URR_3G_GENERAL_STATUS_IND,
   /* Put 1st XXX_STATUS_IND_STRUCT_INFO in front of XXX_EM_INFO_BEGIN 
      in order to show enum_name in XXX_STATUS_IND_STRUCT_INFO not in XXX_EM_INFO_BEGIN. */

   EM_SIBE_3G_SIB_IND_STRUCT_INFO,
   EM_CSCE_SERV_CELL_IND_STRUCT_INFO = 75,
   EM_CSCE_NEIGH_CELL_IND_STRUCT_INFO,
   EM_CSCE_R_STATUS_IND_STRUCT_INFO,
   EM_CSCE_H_STATUS_IND_STRUCT_INFO,
   EM_CSCE_APBCR_STATUS_IND_STRUCT_INFO,
   EM_CSCE_MEAS_RULE_STATUS_IND_STRUCT_INFO,
   EM_CSCE_MULTIPLE_PLMN_IND_STRUCT_INFO,
   
   EM_MEME_INFO_DCH_UMTS_CELL_INFO = 90, MEME_EM_INFO_BEGIN = EM_MEME_INFO_DCH_UMTS_CELL_INFO,
   EM_MEME_INFO_DCH_GSM_CELL_INFO,
   EM_MEME_INFO_DCH_LTE_CELL_INFO,
   EM_MEME_INFO_EVENT_TYPE_1_PARAMETER_STRUCT_INFO,
   EM_MEME_INFO_EVENT_TYPE_2_PARAMETER_STRUCT_INFO,
   EM_MEME_INFO_EVENT_TYPE_3_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_EVENT_TYPE_4_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_EVENT_TYPE_5_PARAMETER_STRUCT_INFO,
//   EM_MEME_INFO_EVENT_TYPE_6_PARAMETER_STRUCT_INFO,
   EM_MEME_INFO_DCH_H_SERVING_CELL_INFO,
   EM_MEME_INFO_DCH_3G_BLER_INFO, 
   EM_MEME_INFO_GSM_CELL_INFO, //for CMCC FT Tool
   EM_MEME_INFO_LTE_CELL_INFO, //for CMCC FT Tool
   MEME_EM_INFO_END = EM_MEME_INFO_LTE_CELL_INFO,

   EM_RRCE_TGPS_STATUS_IND= 110,  
   EM_SLCE_SRNCID_STATUS_IND,
//#ifdef __UMTS_TDD128_MODE__
   EM_UAS_3G_TDD128_HANDOVER_SEQUENCE_IND = 130,
//#endif
   EM_RRCE_3G4_REDIR_EVENT,

   EM_SLCE_PS_DATA_RATE_STATUS_IND = 140,
   EM_RRCE_DCH_STATE_CONFIGURATION_STATUS_IND = 155,   
   EM_RRCE_FACH_STATE_CONFIGURATION_STATUS_IND,   
   EM_RRCE_CS_OVER_HSPA_STATUS_IND,
   URR_EM_INFO_END = EM_RRCE_CS_OVER_HSPA_STATUS_IND,
//#endif /* __UMTS_RAT__ */   
//#ifdef __UMTS_R8__
   /* __UL1_EM_MODE__ */
   UL1_EM_HS_DSCH_CONFIGURATION_INFO = 170, UL1_EM_INFO_BEGIN = UL1_EM_HS_DSCH_CONFIGURATION_INFO,
   UL1_EM_EDCH_CONFIGURATION_INFO,
   UL1_EM_CPC_CONFIGURATION_INFO,
   UL1_EM_SECONDARY_HS_CONFIGURATION_STATUS_INFO,
   UL1_EM_PRIMARY_HS_DSCH_BLER_INFO,
   UL1_EM_SECONDARY_HS_DSCH_BLER_INFO,
   UL1_EM_EDCH_ACK_RATE_INFO,   UL1_EM_INFO_END = UL1_EM_EDCH_ACK_RATE_INFO,
//#endif
//#if defined(__UMTS_RAT__) && defined(__UMTS_TDD128_MODE__)
   /* __UL2_EM_MODE__ */
   UL2_EM_ADM_POOL_STATUS_IND_STRUCT_INFO = 185, UL2_EM_INFO_BEGIN = UL2_EM_ADM_POOL_STATUS_IND_STRUCT_INFO,
   UL2_EM_PS_DATA_RATE_STATUS_IND_STRUCT_INFO, 
   UL2_EM_HSDSCH_RECONFIG_STATUS_IND_STRUCT_INFO,
   UL2_EM_URLC_EVENT_STATUS_IND_STRUCT_INFO,
   UL2_EM_3G_BLER_IND_STRUCT_INFO,
   /*UMAC new EM Arch*/
   /***HSUPA SI***/
   UL2_EM_HSUPA_SI_IND_STRUCT_INFO,
   /***HSUPA SI***/
   UL2_EM_INFO_END = UL2_EM_HSUPA_SI_IND_STRUCT_INFO,
//#endif

   /*ERRC_EM_MODE, here is the start of errc em info definition*/
   ERRC_EM_MOB_MEAS_INTRARAT_INFO = 210, ERRC_EM_INFO_BEGIN = ERRC_EM_MOB_MEAS_INTRARAT_INFO,
   ERRC_EM_MOB_MEAS_INTERRAT_UTRAN_INFO,
   ERRC_EM_MOB_MEAS_INTERRAT_GERAN_INFO,
   ERRC_EM_AUTOS_CSG_INFO,
   ERRC_EM_CARRS_EVENT_IND,
   ERRC_EM_SIB_EVENT_IND,   
   ERRC_EM_MOB_EVENT_IND,
   ERRC_EM_SEC_PARAM,
   ERRC_EM_REEST_INFO,
   ERRC_EM_RECONF_INFO,
   ERRC_EM_RCM_SIM_STS_INFO,
   ERRC_EM_SYS_SIB_RX_STS_INFO,
   ERRC_EM_ERRC_STATE_IND,
   ERRC_EM_OVER_PROC_DELAY_WARNING,
   ERRC_EM_LTE_SUPPORTED_BAND_INFO,
   ERRC_EM_ERRC_KPI_INFO,
   
   /* __ESM_EM_MODE__ */
   ESM_ESM_INFO,
   ESM_L4C_ESM_INFO,
   
   ERRC_EM_ERRC_CONFIG_INFO,
   ERRC_EM_INFO_END = ERRC_EM_ERRC_CONFIG_INFO,
   
   /* __EMM_EM_MODE__*/
   EMM_EM_SEC_INFO = 230, EMM_EM_INFO_BEGIN = EMM_EM_SEC_INFO,
   EMM_EM_PLMNSEL_INFO,
   EMM_EM_CONN_INFO,
   EMM_EM_NASMSG_INFO,
   EMM_EM_CALL_INFO,
   EMM_EM_REG_ATTACH_INFO,
   EMM_EM_REG_DETACH_INFO,   
   EMM_EM_REG_TAU_INFO,
   EMM_EM_REG_COMMON_INFO,
   EMM_EM_SV_INFO,
   EMM_EM_RATBAND_INFO,
   EMM_EM_TIMERSRV_INFO,
   EMM_EM_USIMSRV_INFO,
   EMM_EM_NVMSRV_INFO,
   EMM_EM_INFO_END = EMM_EM_NVMSRV_INFO,

   EMM_L4C_EMM_INFO,
   
   EM_EL2_OV_STATUS,
   EM_EL1_OV_STATUS,
   EM_QBM_STATUS,
   EM_UPCM_STATUS,

   /* EL1TX */
   EL1TX_EM_TX_INFO,

   EM_CSR_STATUS_IND,

   RAC_EM_INFO,

   /* EL2 public status */
   EM_EL2_PUB_STATUS,

   EMM_L4C_LAI_CHANGE_INFO,

   /*RATCM*/
   RATCM_EM_23G_RAT_CHANGE_IND, RATCM_EM_INFO_BEGIN = RATCM_EM_23G_RAT_CHANGE_IND,
   RATCM_EM_INFO_END = RATCM_EM_INFO_BEGIN + 20,
      
   /* L4C */ 
   EM_L4C_RAT_CHANGE_IND, L4C_EM_INFO_BEGIN = EM_L4C_RAT_CHANGE_IND,
   L4C_EM_INFO_END = L4C_EM_INFO_BEGIN + 50,  

   /* IPCORE */
   IPC_EM_UL_THROTTLE_STATUS,
   
   /*ERRC_EM_MODE, here is the start of errc em info definition of Range 2*/
   ERRC_EM_SERV_IR_NEIGHBOR_INFO, ERRC_EM_INFO_BEGIN_R2 = ERRC_EM_SERV_IR_NEIGHBOR_INFO,
   ERRC_EM_IR_REDIR_EVENT,
   ERRC_EM_IRAT_MEAS_CFG,
   ERRC_EM_INFO_END_R2 = ERRC_EM_IRAT_MEAS_CFG,
   ERRC_EM_INFO_END_RESERVED = ERRC_EM_INFO_BEGIN_R2 + 30,
   
   NUM_OF_EM_INFO,
   INVALID_EM_INFO = 0x7fffffff //end tag force this enum 4 bytes, for alignment purpose. Don't remove
} em_info_enum;

/**************************************************************************
  * common structure/enumeration
  **************************************************************************/
typedef struct 
{
	kal_uint8 mcc1;
	kal_uint8 mcc2;
	kal_uint8 mcc3;
	kal_uint8 mnc1;
	kal_uint8 mnc2;
	kal_uint8 mnc3;
} plmn_struct;

typedef enum {
    ACCESS_CLASS_NOT_BARRED      = 0,
    ACCESS_CLASS_EMERGENCY_ONLY  = 1,
    ACCESS_CLASS_ALL_BARRED      = 2,
    ACCESS_CLASS_NOT_AVAILABLE   = 3
} access_class_level_enum;

typedef enum {
    PPAC_FOR_NONE_DOMAIN = 0, 
    PPAC_FOR_CS_DOMAIN = 1, 
    PPAC_FOR_PS_DOMAIN = 2, 
    PPAC_FOR_CS_PS_DOMAIN = 3, 
    PPAC_NOT_AVAILABLE = 4
} ppac_domain_enum;

//mtk01616_080622: for L4A code gen (Do NOT remove)
#define EM_INFO_REQ_NUM NUM_OF_EM_INFO

/* local parameter structures */

/* To identify the status of info_request */
typedef enum
{
    EM_OFF = 0,
    EM_ON  = 1,
    EM_NC  = 2 /* No change */
} em_info_status_enum;

/* For DHLL4C_EM_UPDATE_REQ */
typedef struct
{
   LOCAL_PARA_HDR
   em_info_status_enum  info_request[NUM_OF_EM_INFO];
} dhll4c_em_update_req_struct;

/* EL1TX */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    /* cell info */
    kal_uint8  band;
    kal_uint8  ant_port;
    kal_uint8  dl_bw;   // 100kHz
    kal_uint8  ul_bw;   // 100kHz
    kal_uint8  tdd_cfg; // TDD: 0~6, FDD: 0xFF
    kal_uint8  sp_cfg;  // TDD: 0~9, FDD: 0xFF
    kal_uint8  tm;      // 1~8
    kal_int16  pci;     // 0~503
    kal_uint16 earfcn;
    kal_uint16 dlFreq;  // 100kHz
    kal_uint16 ulFreq;  // 100kHz

    /* DL Qual indicator */
    kal_int16  dl_rsrp[2]; // -255: disable, -140 ~ 18 (dBm)
    kal_int16  dl_rssi[2]; // -255: disable, -140 ~ 18 (dBm)
    kal_int16  snr[2];
    kal_int16  rsrp;
    kal_int16  rsrq;
    kal_int16  os_snr;

    /* PHR, CQI, RI*/
    kal_int16  phr;
    kal_int16  ta;
    kal_int16  cqi;
    kal_int16  cqi1;
    kal_int16  ri;

    /* PWR info */
    kal_int16  prach_tx_power_ave;
    kal_int16  pucch_tx_power_ave;
    kal_int16  pusch_tx_power_ave;
    kal_int16  srs_tx_power_ave;

    /* DL info */
    kal_uint32 DL_Tput;

    /* UL info */
    kal_uint32 UL_Tput;

    /* reserved */
    kal_int16  data[8];

} em_el1tx_status_ind_struct;

/* EL2 public EM info */
typedef struct
{
    kal_uint8 srb_num;
    kal_uint8 drb_num;
} em_el2_pub_info_t;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum        em_info;
    
    em_el2_pub_info_t   el2_info;
    
} em_el2_pub_status_ind_struct;

extern em_el2_pub_status_ind_struct el2_pubstatus_g;

/* EL1 RX PATH set command*/
typedef enum {
    BOTH_RX_PATH = 0,
    RX_PATH_0    = 1,
    RX_PATH_1    = 2
} rx_path_setting_enum;

typedef enum {
    SET_RX_PATH  = 0,
    READ_RX_PATH = 1
} rx_path_cmd_type;

#define UL1_RX_PATH_BASE 10

typedef enum {
    UL1_RX_MAIN_ONLY = 0,
    UL1_RX_RXD_ONLY  = 1,
    UL1_RX_BOTH      = 2,
    UL1_RX_OFF       = 3   // Resume default
} ul1_rx_path_set_enum;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    rx_path_cmd_type cmd_type;
    rx_path_setting_enum rx_path;
    kal_bool nvram_write;  // This flag is used to indicate whether need to save the setting in NVRAM or not
}l4cel1_set_rx_path_req_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    rx_path_cmd_type cmd_type;
    kal_bool rx_path_set_result; //only used for Rx path command set
                                                  //1:success, 0:failed
    rx_path_setting_enum rx_path; //only used for Rx path command read
}l4cel1_set_rx_path_cnf_struct;


typedef struct 
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    ul1_rx_path_set_enum rx_path; 
    kal_bool nvram_write;  // This flag is used to indicate whether need to save the setting in NVRAM or not
    rx_path_cmd_type cmd_type;
}l4cul1_set_rx_path_req_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    kal_bool  result;
    rx_path_cmd_type cmd_type;
    ul1_rx_path_set_enum  rx_path;
}l4cul1_set_rx_path_cnf_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_uint8 band;
    kal_uint16 dl_earfcn;
}l4cel1_rx_rssi_verify_req_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_int32 rssi0_dBm;
    kal_int32 rssi1_dBm;
}l4cel1_rx_rssi_verify_ind_struct;

/* EL1 RF TEMPURATURE */
typedef struct 
{
    LOCAL_PARA_HDR
}l4cel1_get_rf_temperature_req_struct;

typedef struct 
{
    LOCAL_PARA_HDR
    kal_int16 rf_temperature; /* range : -40 ~ 140, 0x8000 means invalid value */
}l4cel1_get_rf_temperature_cnf_struct;

/* EL1 TX POWER */
typedef struct 
{
    LOCAL_PARA_HDR
}l4cel1_get_tx_power_req_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_int8 tx_power; /* tx power : -50, -127 : invalid */
}l4cel1_get_tx_power_cnf_struct;

/* For TSTL4C_EM_START_REQ, TSTL4C_EM_STOP_REQ */
typedef struct
{
   LOCAL_PARA_HDR
   module_type mod_id;
   request_info_type	info_request;
} tstl4c_em_start_req_struct;

typedef tstl4c_em_start_req_struct tstl4c_em_stop_req_struct;


/* RR structure */		
typedef struct
{
	kal_uint8	crh;   //CELL-RESELECT-HYSTERESIS
	kal_uint8	ms_txpwr;   // 	maximum TX power level an MS may use when accessing on a CCH
	kal_uint8	rxlev_access_min;   //	minimum received signal level at the MS for which it is permitted to access the system
} rr_em_cell_select_para_info_struct;
			
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_cell_select_para_info_struct rr_em_cell_select_para_info;
} em_rrm_cell_select_para_info_ind_struct;
			
typedef struct
{
	kal_uint8	channel_type;   //	channel type
	kal_uint8	tn;   //	timeslot number
	kal_uint8	tsc;   //	training sequence code
	kal_uint8	hopping_flag;   //	hopping or not
	kal_uint8	maio;   //	MAIO value
	kal_uint8	hsn;   //	HSN value
	kal_uint8	num_of_carriers;   //	number of carriers in the BA list(in the non-hopping case, this shall be set to 1)
	kal_uint16	arfcn[64];   //	ARFCN value in the MA
	kal_bool     is_BCCH_arfcn_valid; /*the BCCH_arfcn is only valid 
	                              when receives H.O cmd in DEDI-state*/
	kal_uint16 BCCH_arfcn;   //	Target_BCCH carrier
	
	/*ZY:2006-08-15 add cipher algo for EM */
	kal_uint8	cipher_algo;  // ciphering value, OFF/A51/A52
	kal_uint8 imeisv_digit[16]; /* To show IMEISV if sent in ciphering mode setting procedure */
	
    kal_uint8 channel_mode;

	/* brwang, 051024, [AMR engineering mode info.] */
       #ifdef __AMR_SUPPORT__
       kal_bool amr_valid; /* the AMR(TRUE) or not(FALSE) */
       kal_uint8 mr_ver;   /* MultiRate speech VERsion : 001-amr verion 1*/
       kal_bool nscb;      /* Noise Supression Control Bit : 0-noise supression is used */
       kal_bool icmi;       /* Initial Codec Mode Indicator : 0-is defined bythe implicit rule */
       kal_uint8 start_codec_mode; /* Start Codec Mode */
       kal_uint8 acs;       /* AMR Codec Activate Set */
       kal_uint8 threshold[3]; /* Threshold1/Threshold2/Threshold3 */
       kal_uint8 hysteresis[3]; /* Hysteresis1/Hysteresis2/Hysteresis3 */
       #endif
} rr_em_channel_descr_info_struct;	//This shall be used in IDLE and DEDI state
			
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_channel_descr_info_struct rr_em_channel_descr_info;
} em_rrm_channel_descr_info_ind_struct;
			
typedef struct
{	
	kal_uint8	mscr;   //	MSC release
	kal_uint8	att;   //	att flag
	kal_uint8	bs_ag_blks_res;   //	BS-AG-BLKS-RES
	kal_uint8	ccch_conf;   //	CCCH-CONF
	kal_uint8	cbq2;   //	Cell Bar Qualify 2
	kal_uint8	bs_pa_mfrms;   //	BS-PA-MFRMS
	kal_uint8	t3212;   //	T3212 timeout value
} rr_em_ctrl_channel_descr_info_struct;
			
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_ctrl_channel_descr_info_struct rr_em_ctrl_channel_descr_info;
} em_rrm_ctrl_channel_descr_info_ind_struct;

typedef struct
{		
	kal_uint8	max_retrans;   //	MAX Retrans value
	kal_uint8	tx_integer;   //	TX integer
	kal_uint8	cba;   //	cell bar for access
	kal_uint8	re;   //	call reestablishment allowed
	kal_uint8	acc_class[2];   //	acces control class
	kal_bool	CB_supported;	// cell broadcast is supported
} rr_em_rach_ctrl_para_info_struct;
			
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_rach_ctrl_para_info_struct rr_em_rach_ctrl_para_info;
} em_rrm_rach_ctrl_para_info_ind_struct;
			
typedef struct
{			
	kal_uint16	max_value;   //	timeout value for the DSF or RLF
	kal_int16	current_value;   //	current value in the DSF or RLF calculation
	kal_uint8	dtx_ind;	//DTX indicator
	kal_uint8	dtx_used;	//DTX used or not
	kal_bool	is_dsf;		//timeout value for the DSF or RLF	
} rr_em_radio_link_counter_info_struct;  //This shall be used in IDLE and DEDI state
			
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_radio_link_counter_info_struct rr_em_radio_link_counter_info;
} em_rrm_radio_link_counter_info_ind_struct;

typedef struct
{
    kal_bool    is_valid;
    kal_uint8   cs_report_type;
    kal_bool    is_invalid_bsic_rp;
    kal_uint8   cs_serv_band_rp;
    kal_uint8   cs_multi_band_rp;
    /* When cs_rp_threshold_850 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_850;
    kal_uint8   cs_rp_offset_850;
    /* When cs_rp_threshold_900 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_900;
    kal_uint8   cs_rp_offset_900;
    /* When cs_rp_threshold_1800 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_1800;
    kal_uint8   cs_rp_offset_1800;
    /* When cs_rp_threshold_1900 is eqaul to 0xFF, it means never */
    kal_uint8   cs_rp_threshold_1900;
    kal_uint8   cs_rp_offset_1900; 
} rr_em_cs_meas_param_struct;

typedef struct
{
    kal_bool    is_valid;
    kal_uint8   ps_report_type;
    kal_bool    is_invalid_bsic_rp;
    kal_uint8   ps_serv_band_rp;
    kal_uint8   ps_multi_band_rp;
    /* When ps_rp_threshold_850 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_850;
    kal_uint8   ps_rp_offset_850;
    /* When ps_rp_threshold_900 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_900;
    kal_uint8   ps_rp_offset_900;
    /* When ps_rp_threshold_1800 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_1800;
    kal_uint8   ps_rp_offset_1800;
    /* When ps_rp_threshold_1900 is eqaul to 0xFF, it means never */
    kal_uint8   ps_rp_threshold_1900;
    kal_uint8   ps_rp_offset_1900;
} rr_em_ps_meas_param_struct;

typedef struct
{

    kal_uint8            rr_state;                    /* NULL: 0, INACTIVE: 1, SELECTION: 2
                                                       * IDLE: 3, ACCESS: 4. PKT_TRANSFER: 6
                                                       * DEDICATED:6, RESELCTION: 7 */
    kal_uint8            meas_mode;                   /* GSM: 0, GPRS_CCCH: 1, GPRS_PMO_CCCH: 2
                                                       * GPRS_PCCCH = 3 */
    kal_uint16           serving_arfcn;               /* serving cell ARFCN */
    kal_uint8            serving_bsic;                /* serving cell BSIC */
    kal_uint8            serving_current_band;
    kal_uint8            serv_gprs_supported;         /* serving cell support GPRS or not */
    kal_int16            serv_rla_in_quarter_dbm;     /* RSSI level for serving cell 
                                                       * 1. BCCH in IDLE-state
                                                       * 2. TCH in DEDI-state
                                                       * 3. PDTCH in TRANSFER-state */
    kal_uint8            serv_rla_reported_value;     /* Reported value of RSSI level for serving cell */
    kal_bool             is_serv_BCCH_rla_valid;      /* To indicate if the serv_BCCH RSSI is valid*/               
    kal_int16            serv_BCCH_rla_in_dedi_state; /*RSSI level for serving cell (BCCH) in DEDI-State */
    kal_uint8            quality;                     /* serving cell -TCH measured quality */
    kal_bool             gprs_pbcch_present;          /* To indicate if the current cell supports GPRS 
                                                       * PBCCH is present */
    kal_bool             gprs_c31_c32_enable;         /* To indicate if the current mode is GPRS_PMO_MODE 
                                                       * or GPRS_PCCCH_MODE.
                                                       */  
    kal_int16            c1_serv_cell;                /* C1 value for the serving cell */
    kal_int16            c2_serv_cell;                /* if gprs_c31_c32_enable is false, this field is shown 
                                                       * as c2_value for serv_cell.
                                                       * if gprs_c31_c32_enable is true, this field is shown 
                                                       * as c32_value for serv_cell */
    kal_int16            c31_serv_cell;               /* if gprs_c31_c32_enable is false, this field is ignore
                                                       * if gprs_c31_c32_enable is true, this field shall be 
                                                       * shown in based on report c31_value */
    kal_uint8            num_of_carriers;             /* number of carriers in the BA list */
    kal_uint16           nc_arfcn[32];                /* ARFCN value in the BA list (The list will be sorted 
                                                       * by the RSSI level */
    kal_int16            rla_in_quarter_dbm[32];      /* rssi level for each carrier */
    kal_uint8            rla_in_reported_value[32];   /* Reported value of RSSI level for each carrier. */
    kal_uint8            nc_info_status[32];          /* Bit0 = 0: "nc_bsic","frame_offset","ebit_offset" is invalid
                                                       * Bit0 = 1: "nc_bsic","frame_offset","ebit_offset" is valid
                                                       * Bit1 = 0: "c1","c2" is invalid
                                                       * Bit1 = 1: "c1","c2" is valid 
                                                       * Bit2 = 0: "gprs_status" is invalid
                                                       * Bit2 = 1: "gprs_status" is valid */
    kal_uint8            nc_bsic[32];                 /* neighbor cell BSIC */
    kal_int32            frame_offset[32];            /* frame offset for each carrier */
    kal_int32            ebit_offset[32];             /* ebit offset for each carrier */
    kal_int16            c1[32];                      /* C1 value for the neighbor cell */
    kal_int16            c2[32];                      /* if gprs_c31_c32_enable is false, this field is shown as 
                                                       * c2_value for nbr_cell
                                                       * if gprs_c31_c32_enable is true, this field is shown as 
                                                       * c32_value for nbr_cell */
    kal_int16            c31[32];                     /* C31 value for the neighbor cell */ 
    kal_uint8            multiband_report;            /* MULTIBAND_REPORT value */
    kal_uint8            timing_advance;              /* Timing advance, range is 0 - 63 */
    kal_int16            tx_power_level; 
    kal_int16            serv_rla_full_value_in_quater_dbm;
    kal_uint8            nco;
    kal_uint8            rxqual_sub;                  /* rx quality (sub), range is 0 - 7 */
    kal_uint8            rxqual_full;                 /* RX quality (full), range is 0 - 7 */
    kal_int16            using_tx_power_in_dbm;       /* DL_DTX_AND_TX_POWER */
#ifdef __AMR_SUPPORT__
    kal_bool             amr_info_valid;
    kal_uint8            cmr_cmc_cmiu_cmid;
    kal_uint8            c_i;
    kal_uint16           icm;
    kal_uint16           acs;
    kal_bool             dl_dtx_used;                 /* DL_DTX_AND_TX_POWER */ 
    em_amr_mode_enum cmr;
    em_amr_mode_enum cmc;
    em_amr_mode_enum amr_ul_mode;
    em_amr_mode_enum amr_dl_mode;
#endif /* __AMR_SUPPORT__ */
#ifdef __FWP_NC_LAI_INFO__
    kal_uint8            num_of_nc_lai;               /* how many valid LAI info in nc_lai[] array */
    rr_em_lai_info_struct nc_lai[6];                  /* store LAI and CID for at most 6 strongest neighbor cells */
#endif /* __FWP_NC_LAI_INFO__ */
    rr_em_cs_meas_param_struct cs_meas_param;
    rr_em_ps_meas_param_struct ps_meas_param;
} rr_em_measurement_report_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_measurement_report_info_struct rr_em_measurement_report_info;
} em_rrm_measurement_report_info_ind_struct;

/*ZY : 2007/07/25 : Add for Cell allocation list*/
typedef struct
{
        kal_uint8   valid;
        kal_uint8   number_of_channels;
        kal_uint16 arfcn_list[64];
} rr_em_ca_list_info_struct;  

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_ca_list_info_struct rr_em_ca_list_info;
} em_rrm_ca_list_info_ind_struct;

typedef struct
{	
	kal_uint8	msg_type;	/*receives msg type from network in Dedi-State
	                          0: Assignment Command
	                          1: Channel Release
	                          2: Additional Assignment 
	                          3: Classmark Enquiry
	                          4: Ciphering Mode Command
	                          5: Configure Change Command
	                          6: Handover Command
	                          7: Frequency Redefinition
	                          8: Channel Mode Modify
	                          9: Cell Selection Indicator*/
	                           	                           

   kal_uint8 rr_cause;

} rr_em_control_msg_info_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_control_msg_info_struct rr_em_control_msg_info;

} em_mac_control_msg_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_control_msg_info_struct rr_em_control_msg_info;
} em_rrm_control_msg_info_ind_struct;

/*Byron: 2006/08/06: Add for SI2q information*/
typedef struct
{
	kal_bool 	present;	
	kal_uint8 no_of_instance;
	kal_bool 	emr_report;
       kal_bool 	pemr_report;
	kal_bool 	umts_parameter_exist;
} rr_em_si2q_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_si2q_info_struct rr_em_si2q_info;
} em_rrm_si2q_info_ind_struct;

/*Byron: 2006/08/06: Add for measurement information*/
typedef struct
{
	kal_bool 	present;
	kal_uint8 no_of_instance;
	kal_bool 	emr_report;
	kal_bool 	umts_parameter_exist;
} rr_em_mi_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_mi_info_struct rr_em_mi_info;
} em_rrm_mi_info_ind_struct;

/* James 2012/8/15: move up gprs info for EM UT */
typedef struct 
{
	kal_uint32 t3192;         // in msec
	kal_uint32 t3168;         // in msec
	kal_uint8  rp;            // radio priority
	kal_uint8  gprs_support;  // GPRS channel request support(0 not support, 1 support, 2 support but not decode)
	kal_uint8  egprs_support; // EGPRS channel request support(0 not support, 1 support)
	kal_uint8  sgsn_r;		  // PS domain is R99 or R98(0 R98, 1 R99)
	kal_uint8  pfc_support;   // packet flow context support(0 not support, 1 support)
	kal_uint8  epcr_support;  // EGPRS channel request support(0 not support, 1 support)
	kal_uint8  bep_period;	  // BEP period
}rr_em_gprs_general_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_gprs_general_info_struct rr_em_gprs_general_info;
} em_rrm_gprs_general_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_lai_info_struct rr_em_lai_info;
} em_rrm_lai_info_ind_struct;

typedef struct
{
	kal_bool 	is_greater_than_85db;	/*serving cell power is greater than 85dbm lasts for 5s*/
}rr_em_serv_cell_power_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_serv_cell_power_struct rr_em_serv_cell_power_status;
}em_rrm_serv_cell_power_status_ind_struct;

typedef struct
{
	kal_bool with_4g_neighbor;	/*SI contains 4g neigbor cell or not*/
}rr_em_4g_neigbor_cell_status_sturct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
	rr_em_4g_neigbor_cell_status_sturct rr_em_4g_neighbor_status;
}em_rrm_ir_4g_neighbor_cell_status_ind_struct;

typedef struct
{
	kal_bool with_3g_neighbor;	/*SI contains 3g neigbor cell or not*/
}rr_em_3g_neigbor_cell_status_sturct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;
	rr_em_3g_neigbor_cell_status_sturct rr_em_3g_neighbor_status;
}em_rrm_ir_3g_neighbor_cell_status_ind_struct;

/**************************************************************************
  * GSM MM - Engineer Mode
  *
  * Notes: Following structures are maintained by RR task                                               
  **************************************************************************/
/***************************** Beging of RR MM EM Config  **************************/
#define MAX_NR_RR_EM_IR_RESEL_STATUS 6
#define MAX_NR_RR_EM_3G_MEAS_STATUS  6
#define MAX_NR_RR_EM_4G_MEAS_STATUS  6
#define MAX_NR_RR_EM_3G_MEAS_INFO    9
#define MAX_NR_RR_EM_4G_MEAS_INFO    9

#define INVALID_GSM_PRIORITY         0x2B
#define THR_PRIO_SEARCH_ALWAYS       0x7F
#define THR_GSM_LOW_ALWAYS           0xFF
#define GSM_REPORT_THR_NEVER         0xFF

#define INVALID_UMTS_QSRCH_C         0xFF
#define INVALID_UMTS_MULTI_REPORT    0xFF
#define INVALID_UMTS_FDD_QMIN_OFF    0xFF
#define INVALID_UMTS_FDD_RSCPMIN     0x7F
#define INVALID_UMTS_FDD_REP_THR_2   0xFF
#define INVALID_UMTS_PRIORITY        0x2B
#define INVALID_UMTS_THR_HIGH        0xFF
#define INVALID_UMTS_THR_LOW         0xFF
#define INVALID_UMTS_QRX_LEVMIN      0x7F
#define UMTS_REPORT_THR_NEVER        0xFF
#define UMTS_FDD_QOFFSET_ALWYAS      0x7F

#define INVALID_LTE_QSRCH_C          0xFF
#define INVALID_LTE_QSRCH_C_INIT     0xFF
#define INVALID_LTE_MULTI_REPORT     0xFF
#define INVALID_LTE_PRIORITY         0x2B
#define INVALID_LTE_THR_HIGH         0xFF
#define INVALID_LTE_THR_LOW          0xFF
#define INVALID_LTE_QRX_LEVMIN       0x7FFF
#define INVALID_LTE_THR_HIGH_Q       0x7F
#define INVALID_LTE_THR_LOW_Q        0x7F
#define INVALID_LTE_QMIN             0x7F
#define INVALID_LTE_QQUALMIN         0x7F
#define INVALID_LTE_RSRPMIN          0x7FFF
#define LTE_REPORT_THR_NEVER         0xFF

typedef enum {
    RRM_EM_IR_MEAS_STOPPED                = 0x00,
    RRM_EM_IR_FIXED_MEAS_START            = 0x01,
    RRM_EM_IR_70S_PRIO_MEAS_START         = 0x02,
    RRM_EM_IR_70S_PRIO_N_FIXED_MEAS_STRAT = 0x03,
    RRM_EM_IR_25S_PRIO_MEAS_START         = 0x04,
    RRM_EM_IR_25S_PRIO_N_FIXED_MEAS_START = 0x05    
} rrm_em_ir_meas_status_enum;

typedef struct
{
    kal_bool          is_valid;
    /* When geran_priority is equal to 0x2B, it means geran_priority is invalid. */
    kal_int8          geran_priority;
    /* When thresh_priority_search is eqaul to 0x7F, it measns always. */
    kal_int8          thresh_priority_search;
    /* When thresh_GSM_low is equal to 0xFF, it means always. */
    kal_uint8         thresh_GSM_low;
    /* When h_prio is equal to 0, it means h_prio is disabled. */  
    kal_uint8         h_prio;
    kal_uint8         t_reselection;    
}rrm_em_ir_2g_parameter_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of ir_source is the enumeration value
     * SRC_INVALID = 0,
     * SRC_SI      = 1,
     * SRC_MI      = 2,
     * SRC_PSI     = 3,
     * SRC_PMO     = 4
     */ 
    kal_uint8         ir_source;
    kal_uint8         qsearch_i;
    /* When qsearch_c is eqaul to 0xFF, qsearch_c is invalid */
    kal_uint8         qsearch_c;
    kal_uint8         qsearch_c_initial;
    kal_uint8         qsearch_p;
#ifdef __UMTS_FDD_MODE__
    /* When fdd_qoffset is eqaul to 0x7F, it measns always. */
    kal_int8          fdd_qoffset;
    kal_int8          fdd_qmin;
    /* When fdd_qmin_off is equal to 0xFF, fdd_qmin_off is invalid */
    kal_uint8         fdd_qmin_off;
    /* When fdd_rscpmin is equal to 0x7F, fdd_rscpmin is invalid */
    kal_int8          fdd_rscpmin;
    kal_uint8         fdd_rep_quant;
    /* When fdd_multirat_reporting is eqaul to 0xFF, fdd_multirat_reporting is invalid */
    kal_uint8         fdd_multirat_reporting;
    kal_uint8         fdd_reporting_offset;
    /* When fdd_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         fdd_reporting_threshold;
    /* When fdd__reporting_threshold is equal to 0xFF, fdd_reporting_threshold_2 is invalid */
    kal_uint8         fdd_reporting_threshold_2;
    kal_uint8         fdd_gprs_rep_quant;
    /* When fdd_gprs_multirat_reporting is eqaul to 0xFF, fdd_gprs_multirat_reporting is invalid */
    kal_uint8         fdd_gprs_multirat_reporting;
    kal_uint8         fdd_gprs_reporting_offset;
    /* When fdd_gprs_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         fdd_gprs_reporting_threshold;
    /* When fdd_gprs_reporting_threshold is equal to 0xFF, fdd_gprs_reporting_threshold_2 is invalid */
    kal_uint8         fdd_gprs_reporting_threshold_2;
#endif /*__UMTS_FDD_MODE__*/

#ifdef __UMTS_TDD128_MODE__
    kal_int8          tdd_qoffset;
    /* When tdd_multirat_reporting is eqaul to 0xFF, tdd_multirat_reporting is invalid */
    kal_uint8         tdd_multirat_reporting;
    kal_uint8         tdd_reporting_offset;
    /* When tdd_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         tdd_reporting_threshold;
    /* When tdd_gprs_multirat_reporting is eqaul to 0xFF, tdd_gprs_multirat_reporting is invalid */
    kal_uint8         tdd_gprs_multirat_reporting;
    kal_uint8         tdd_gprs_reporting_offset;
    /* When tdd_gprs_reporting_threshold is eqaul to 0xFF, it means never */
    kal_uint8         tdd_gprs_reporting_threshold; 
#endif /*__UMTS_TDD128_MODE__*/
}rrm_em_ir_3g_parameter_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of ir_source is the enumeration value
     * LTE_PARA_INVALID = 0,
     * LTE_PARA_FROM_SI2Q = 1,
     * LTE_PARA_FROM_MI = 2,
     * LTE_PARA_FROM_PMO = 3
     */
    kal_uint8         ir_source;
    /* When qsearch_c_eutran_initial is eqaul to 0xFF, qsearch_c_eutran_initial is invalid */
    kal_uint8         qsearch_c_eutran_initial;
    /* When qsearch_c_eutran is eqaul to 0xFF, qsearch_c_eutran is invalid */
    kal_uint8         qsearch_c_eutran;
    kal_uint8         qsearch_p_eutran;
    kal_uint8         eutran_rep_quant;
    /* When eutran_multirat_reporting is eqaul to 0xFF, eutran_multirat_reporting is invalid */
    kal_uint8         eutran_multirat_reporting;
    /* When eutran_6bit_fdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_6bit_fdd_report_threshold;
    kal_uint8         eutran_6bit_fdd_report_threshold_2;
    kal_uint8         eutran_6bit_fdd_report_offset;
    /* When eutran_6bit_tdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_6bit_tdd_report_threshold;
    kal_uint8         eutran_6bit_tdd_report_threshold_2;
    kal_uint8         eutran_6bit_tdd_report_offset;
    kal_int16         eutran_3bit_fdd_meas_report_offset;
    kal_uint8         eutran_3bit_fdd_report_threshold_2;
    kal_uint8         eutran_3bit_fdd_report_offset;
    kal_int16         eutran_3bit_tdd_meas_report_offset;
    kal_uint8         eutran_3bit_tdd_report_threshold_2;
    kal_uint8         eutran_3bit_tdd_report_offset;
    kal_uint8         eutran_3bit_report_granularity;
    kal_uint8         eutran_gprs_rep_quant;
    /* When eutran_gprs_multirat_reporting is eqaul to 0xFF, eutran_gprs_multirat_reporting is invalid */
    kal_uint8         eutran_gprs_multirat_reporting;
    /* When eutran_gprs_6bit_fdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_gprs_6bit_fdd_report_threshold;
    kal_uint8         eutran_gprs_6bit_fdd_report_threshold_2;
    kal_uint8         eutran_gprs_6bit_fdd_report_offset;
    /* When eutran_gprs_6bit_tdd_report_threshold is eqaul to 0xFF, it means never */
    kal_uint8         eutran_gprs_6bit_tdd_report_threshold;
    kal_uint8         eutran_gprs_6bit_tdd_report_threshold_2;
    kal_uint8         eutran_gprs_6bit_tdd_report_offset;
} rrm_em_ir_4g_parameter_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_2g_parameter_struct ir_2g_parameter;
    rrm_em_ir_3g_parameter_struct ir_3g_parameter;
    rrm_em_ir_4g_parameter_struct ir_4g_parameter;
} em_rrm_ir_parameter_status_ind_struct;

typedef struct
{
    kal_bool         is_valid;
    /* The value of rat is the enumeration value
     * UMTS = 0x01,
     * LTE = 0x02 
     */
    kal_uint8        rat;
    /* The value of type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02 
     */
    kal_uint8        type;
    kal_uint16       freq;
    kal_uint16       phy_id;
    kal_int16        strength;
    kal_int16        quality;
    kal_uint32       hit_duration;
    /* The value of hit_criteria is the combination value.
     * IR_RESEL_NO_CRITERIA_HIT = 0x00,
     * IR_RESEL_RANKING_CRITERIA_HIT = 0x01,
     * IR_RESEL_WCDMA_PREFER_HIT = 0x02,
     * IR_RESEL_HIGH_PRIORITY_HIT = 0x10,
     * IR_RESEL_LOW_PRIORITY_HIT  = 0x20,
     * IR_RESEL_ANY_PRIORITY_HIT  = 0x40 
     */  
    kal_uint8        hit_critiria;
}rrm_em_ir_reselect_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_reselect_status_struct ir_reselect_status[MAX_NR_RR_EM_IR_RESEL_STATUS];
} em_rrm_ir_reselect_status_ind_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of cell_type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02 
     */    
    kal_uint8         cell_type;
    kal_uint16        uarfcn;
    kal_uint16        phy_id;
    kal_int16         strength;
    kal_int16         quailty;
    kal_uint8         rep_value;
    kal_uint8         non_rep_value;
    /* The value of fail_type is the enumeration value:
     * IR_INITIAL_VALUE   = 0x00,
     * NEVER_ALLOWED      = 0x01,
     * PLMN_ID_MISMATCHED = 0x02,   
     * LA_NOT_ALLOWED     = 0x03,
     * CELL_BARRED        = 0x04,
     * TEMP_FAILURE       = 0x05,
     * CRITERIA3_NOT_SATISFIED = 0x06,
     * TA_NOT_ALLOWED     = 0x07,
     * CELL_BARRED_FREQ   = 0x08,
     * CELL_BARRED_RESV_OPERATOR = 0x09,
     * CELL_BARRED_RESV_OPERATOR_FREQ = 0x0A,
     * CSG_NOT_ALLOWED = 0x0B
     */
    kal_uint8         fail_type;
}rrm_em_ir_3g_neighbor_meas_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                             em_info;
    rrm_em_ir_3g_neighbor_meas_status_struct ir_3g_neighbor_meas_status[MAX_NR_RR_EM_3G_MEAS_STATUS];
} em_rrm_ir_3g_neighbor_meas_status_ind_struct;

typedef struct
{
   kal_bool                     is_valid;
   kal_uint16                   uarfcn;
   kal_bool                     is_meas_ongoing;
   /* When Bit 7 is 1 (i.e., meas_control_utran & 0x80 == 0x80), meas_control_utran
    * is valid. Then Bit 1 is shown whether this UARFCN should be measured.
    */
   kal_uint8                    meas_control_utran;
   /* When priority is equal to 0x2B, it means priority is invalid. */
   kal_int8                     priority;
   /* When thr_high is equal to 0xFF, it means thr_high is invalid. */
   kal_uint8                    thr_high;
   /* When thr_low is equal to 0xFF, it means thr_low is invalid. */
   kal_uint8                    thr_low;
   /* When qrx_lev_min is equal to 0x7F, it means qrx_level_min is invalid. */
   kal_int8                     qrx_lev_min;
} rrm_em_ir_3g_neighbor_meas_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                           em_info;
    kal_uint8                              rrm_state;
    /* The value of ir_resel_mode is the enumeration value
     * IR_RESEL_MODE_RANKING = 0x00,
     * IR_RESEL_MODE_PRIORITY = 0x01,
     */
    kal_uint8                              ir_resel_mode;
    rrm_em_ir_meas_status_enum             rrm_em_ir_meas_status;
    rrm_em_ir_3g_neighbor_meas_info_struct ir_3g_neighbor_meas_info[MAX_NR_RR_EM_3G_MEAS_INFO];
} em_rrm_ir_3g_neighbor_meas_info_ind_struct;

typedef struct
{
    kal_bool          is_valid;
    /* The value of cell_type is the enumeration value
     * NORMAL = 0x00,
     * CSG = 0x01,
     * HYBRID = 0x02 
     */    
    kal_uint8         cell_type;
    kal_uint16        earfcn;
    kal_uint16        pci;
    /* The value of band is the enumeration value
     * INVALID = 0x00,
     * FDD = 0x01,
     * TDD = 0x02 
     */     
    kal_uint8         band_type;
    kal_int16         rsrp;
    kal_int16         rsrq;
    kal_uint8         rep_value;
    kal_uint8         non_rep_value;
    /* The value of fail_type is the enumeration value:
     * IR_INITIAL_VALUE   = 0x00,
     * NEVER_ALLOWED      = 0x01,
     * PLMN_ID_MISMATCHED = 0x02,   
     * LA_NOT_ALLOWED     = 0x03,
     * CELL_BARRED        = 0x04,
     * TEMP_FAILURE       = 0x05,
     * CRITERIA3_NOT_SATISFIED = 0x06,
     * TA_NOT_ALLOWED     = 0x07,
     * CELL_BARRED_FREQ   = 0x08,
     * CELL_BARRED_RESV_OPERATOR = 0x09,
     * CELL_BARRED_RESV_OPERATOR_FREQ = 0x0A,
     * CSG_NOT_ALLOWED = 0x0B
     */
    kal_uint8         fail_type;
}rrm_em_ir_4g_neighbor_meas_status_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rrm_em_ir_4g_neighbor_meas_status_struct ir_4g_neighbor_meas_status[MAX_NR_RR_EM_4G_MEAS_STATUS];
} em_rrm_ir_4g_neighbor_meas_status_ind_struct;

typedef struct
{
   kal_bool                     is_valid;
   kal_uint16                   earfcn;
   kal_bool                     is_meas_ongoing;  
   /* When Bit 7 is 1 (i.e., meas_control_eutran & 0x80 == 0x80), meas_control_eutran
    * is valid. Then Bit 1 is shown whether this EARFCN should be measured.
    */
   kal_uint8                    meas_control_eutran;
   /* When priority is equal to 0x2B, it means priority is invalid. */
   kal_int8                     priority;
   /* When thr_high is equal to 0xFF, it means thr_high is invalid. */
   kal_uint8                    thr_high;
   /* When thr_low is equal to 0xFF, it means thr_low is invalid. */
   kal_uint8                    thr_low;
   /* When qrx_lev_min is equal to 0x7FFF, it means qrx_level_min is invalid. */
   kal_int16                    qrx_lev_min;
   /* The value of fail_type is the enumeration value:
    * CHECK_INVALID = 0x00, CHECK_RSRQ = 0x01, CHECK_RSRP = 0x02.
    * (1)CHECK_INVALID: qmin, thr_high_q, thr_low_q, qqualmin, and rsrpmin are all invalid.
    * (2)CHECK_RSRQ: qmin is valid, 
    *                thr_high_q, thr_low_q, qqualmin, and rsrpmin are all invalid
    * (3)CHECK_RSRP: qmin is invalid, 
    *                thr_high_q, thr_low_q, qqualmin, and rsrpmin are all valid
    */ 
   kal_uint8                    lte_suitability_check;
   /* When qmin is equal to 0x7F, it means qmin is invalid. */
   kal_int8                     qmin;
   /* When thr_high_q is equal to 0xFF, it thr_high_q qmin is invalid. */
   kal_uint8                    thr_high_q;
   /* When thr_low_q is equal to 0xFF, it thr_low_q qmin is invalid. */
   kal_uint8                    thr_low_q;
   /* When qqualmin is equal to 0x7F, it means qqualmin is invalid. */
   kal_int8                     qqualmin;
   /* When rsrpmin is equal to 0x7FFF, it means rsrpmin is invalid. */
   kal_int16                    rsrpmin;
} rrm_em_ir_4g_neighbor_meas_info_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                           em_info;
    kal_uint8                              rrm_state;
    /* The value of ir_resel_mode is the enumeration value
     * IR_RESEL_MODE_RANKING = 0x00,
     * IR_RESEL_MODE_PRIORITY = 0x01,
     */
    kal_uint8                              ir_resel_mode;
    rrm_em_ir_meas_status_enum             rrm_em_ir_meas_status;
    rrm_em_ir_4g_neighbor_meas_info_struct ir_4g_neighbor_meas_info[MAX_NR_RR_EM_4G_MEAS_INFO];
} em_rrm_ir_4g_neighbor_meas_info_ind_struct;

/***************************** End of RR DM EM Config  ****************************/
/* CC structure */
typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint8   cause;	//channel sync cause
   kal_uint8   channel_type;	//channel type
   kal_uint8   channel_mode;	//channel mode
} em_cc_channel_info_ind_struct;

typedef struct
{
  LOCAL_PARA_HDR
  em_info_enum em_info;
	kal_uint8	call_id;	//call id
	kal_uint8	ti;	//transaction identifier
	kal_uint8	state;	//call state
	kal_uint8	aux_state;	//auxiliary state
   	kal_uint8	pi; //progress indicator
	kal_uint16	cause;	//call disconnect cause
	kal_uint8	cause_location;	//cause originating locatioin   
} em_cc_call_info_ind_struct;

/* CB structure */
typedef struct
{
	kal_uint16	sn;	//serial number
	kal_uint16	mi;	//message identifier
	kal_uint8	dcs;	//data code scheme
	kal_uint8	page;	//current number of this page
	kal_uint8	pages;	//total number of pages
} cb_em_info_struct;
     
/* SS structure */
typedef struct
{			
	kal_uint8	ss_state;	//ciss state
	kal_uint8	ti;	//transaction identifier
	kal_uint8	call_id;	//call id
	kal_uint8	invoke_id;	//invoke id
	kal_uint8	num_invoke;	//number of active invokes
	kal_uint8	op_code;	//operation code
	kal_uint8	ss_code;	//supplementary service code
	kal_uint8	bs_code;	//basic service code
} ss_em_info_struct;

/* MM structure */ 
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8   t3212_val;	//T3212 timer value
    kal_uint8   att_flag;	//ATT flag
    kal_uint8   mm_cause;	//MM Reject cause, if any
    kal_uint8   mm_state;	//MM State
    kal_uint8   mcc[3];	//MCC
    kal_uint8   mnc[3];	//MNC
    kal_uint8   loc[2];	 //registered LAC
    kal_uint8   rac;     //registered RAC
    kal_uint8   tmsi[4];	//TMSI, if valid
    kal_bool is_t3212_running;
    kal_uint16  t3212_timer_value;
    kal_uint16  t3212_passed_time;
    kal_uint8 common_access_class; //for Access Class ?V Common, value defined in access_class_level_enum
    kal_uint8 cs_access_class; //for Access Class ?V CS Domain, value defined in access_class_level_enum
    kal_uint8 ps_access_class; //for Access Class ?V PS Domain, value defined in access_class_level_enum
    ppac_domain_enum paging_for_ppac; //for PPAC - Paging, value defined in ppac_domain_enum
    ppac_domain_enum lr_for_ppac; //for PPAC - Registration, value defined in ppac_domain_enum
    access_class_level_enum lr_access_class; //for PPAC - Registration access class, value defined in access_class_level_enum
    kal_uint8 lu_req_mobile_identity; //mobile identity used in last location update request
#if defined(__WISDOM_EM__) || defined(__ADVANCED_EM__)
    kal_uint8 imsi[9];
    kal_uint8 gsm_update_status;
    kal_uint8 current_rat;
#endif
} em_mm_info_ind_struct;

/* UEM structure */
typedef struct
{
	kal_int32	adc_value;	//battery ADC value
	kal_uint8	battery_level;	//battery level
	kal_uint8	battery_status;	//battery status: battery_status_enum
} uem_em_battery_info;


/* The rr_em_tbf_status_struct is updated whenever TBF is established/reallocated or released. */
typedef struct
{
	kal_uint8	tbf_mode;                // GPRS or EGPRS TBF mode

	/* UL TBF info */
	kal_uint8	ul_tbf_status;      //	access/active/inactive
	kal_uint8	ul_rel_cause;       //	if applicable
	kal_uint8	ul_ts_allocation;   // timeslot allocation  
	kal_uint8 ul_rlc_mode;            // RLC ACK / UNACK mode
	kal_uint8 ul_mac_mode;         // Dynamic allocation / Extended dynamic allocation / Fixed allocation
       /* new created fields */
       kal_uint16 number_rlc_octect;  // RLC requested octect/byte number
	kal_uint8 ul_tfi;
	kal_uint8 ul_granularity;
	kal_uint8 ul_usf;
       kal_uint8 ul_tai;
       kal_uint16 ul_tqi;       
	kal_uint16  ul_window_size;    // GPRS: 64, EGPRS 64 ~1024   
			
       /* DL TBF info */
	kal_uint8	dl_tbf_status;     //	active/inactive/release pending
	kal_uint8	dl_rel_cause;      //	if applicable
	kal_uint8	dl_ts_allocation;      // Ttimeslot allocation
	kal_uint8 dl_rlc_mode;            // RLC ACK / UNACK mode
	kal_uint8 dl_mac_mode;          // Dynamic allocation / Extended dynamic allocation / Fixed allocation
       /* new created fields */
	kal_uint8 dl_tfi;
       kal_uint8 dl_tai;
	kal_uint16 dl_window_size;	// GPRS: 64, EGPRS 64 ~1024   
#ifdef __EGPRS_MODE__	
	kal_uint8 dl_out_of_memory;   // EGPRS IR out of memory indication
#endif /* __EGPRS_MODE__ */
}rr_em_tbf_status_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_tbf_status_struct rr_em_tbf_status;
    
} em_mac_tbf_info_ind_struct;


/* The new rr_em_blk_info_struct is updated every N (configurable?) block period during TBF. 
    N should be adjusted to suitable/smooth display rate. */
typedef struct
{
	/* UL TBF info */       
	kal_uint8	ul_coding_scheme;   
	kal_uint8 ul_cv;
	kal_uint8 ul_tlli;
	kal_uint16 ul_bsn1;
#ifdef __EGPRS_MODE__	
	kal_uint16 ul_bsn2;
       kal_uint8 ul_cps;
	kal_uint8 ul_rsb;
	kal_uint8 ul_spb;
#endif /* __EGPRS_MODE__ */

	/* DL TBF info */
	kal_uint8 dl_c_value_in_rx_level;  /* for both GPRS/EGPRS C value (channel quality) */
       kal_uint8 dl_rxqual;                         /* for GPRS RX QUAL (channel quality) */
       kal_uint8 dl_sign_var;                     /* for GPRS signal variance (channel quality) */
                     
	kal_uint8 dl_coding_scheme;
	kal_uint8 dl_fbi;
	kal_uint16 dl_bsn1;	
#ifdef __EGPRS_MODE__	
	kal_uint16 dl_bsn2;
	kal_uint8 dl_cps;
	kal_uint8 dl_gmsk_mean_bep_lev;	  /* for EGPRS GMSK mean BEP level (channel quality). valid: 0 ~ 31. invalid: 255 */
	kal_uint8 dl_8psk_mean_bep_lev;	  /* for EGPRS 8PSK mean BEP level (channel quality) . valid: 0 ~ 31. invalid: 255 */
       kal_uint8 dl_tn_mean_bep_lev[8];	  /* for EGPRS Timeslot Number mean BEP level (channel quality). valid: 0 ~ 31. invalid: 255 */		
#endif /* __EGPRS_MODE__ */       
       kal_uint8 dl_tn_interference_lev[8]; /* for GPRS/EGPRS Timeslot Number interference (channel quality). valid: 0 ~ 15. invalid: 255 */		       
}rr_em_blk_info_struct;

/* Katie 2013027: em revise */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    rr_em_blk_info_struct rr_em_blk_info;
    
} em_mac_blk_info_ind_struct;


/* Poying: 20101210. Remove for EM_MODE. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if 0 /* TCM EM mode deprecated @ 2013.04 */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

typedef enum{ // mtk01936 SM EM mode
     LOG_EM_MODE_PDP_INACTIVE, // PDP-INACTIVE
     LOG_EM_MODE_PDP_ACTIVE_PENDING, // PDP-ACTIVE-PENDING
     LOG_EM_MODE_PDP_INACTIVE_PENDING, // PDP-INACTIVE-PENDING
     LOG_EM_MODE_PDP_ACTIVE, // PDP-ACTIVE
     LOG_EM_MODE_PDP_MODIFY_PENDING, // PDP-MODIFY-PENDING
     LOG_EM_MODE_PDP_CONTEXT_ENUM_TOTAL
} sm_em_mode_pdp_context_enum;

typedef enum
{
    LOG_EM_MODE_PRIMARY_CONTEXT,
    LOG_EM_MODE_SECONDARY_CONTEXT,
    LOG_EM_MODE_UNKNOWN_CONTEXT
} sm_em_mode_pdp_context_type_enum;

typedef enum
{
    LOG_EM_MODE_MS_INITIATED = 0,
    LOG_EM_MODE_NW_INITIATED = 1
} sm_em_mode_initiated_enum;

typedef enum
{
     LOG_EM_MODE_IPV4_ADDR_TYPE      = 0X21,
     LOG_EM_MODE_IPV6_ADDR_TYPE      = 0X57,
     LOG_EM_MODE_IPV4V6_ADDR_TYPE    = 0X8D, 
     LOG_EM_MODE_PPP_ADDR_TYPE       = 0X01,
     LOG_EM_MODE_OSP_IHOSS_ADDR_TYPE = 0X02,
     LOG_EM_MODE_NULL_PDP_ADDR_TYPE  = 0X03  /* This is added incase if no pdpaddrtype is 
                                  * specified */
} sm_em_mode_pdp_addr_type_enum;

/* BCM stands for bearer control mode. */
typedef enum
{
    LOG_EM_MODE_SM_BCM_NULL    = 0x00,  /* Not yet selected by NW. */
    LOG_EM_MODE_SM_BCM_MS_ONLY = 0x01,  /* 24.008, Sec. 10.5.6.3 (PCO). */
    LOG_EM_MODE_SM_BCM_MS_NW   = 0x02   /* 24.008, Sec. 10.5.6.3 (PCO). */
} sm_em_mode_selected_bcm_enum ;

typedef struct
{
    /* Requested Qos */
    kal_uint8 delay_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 reliability_class; // possible value are Decimal 1, 2, 3, 4, 5
    kal_uint8 peak_throughput; // possible value are Decimal 1~9
    kal_uint8 precedence_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 mean_throughput; // possible value are Decimal 1~18
    kal_uint8 traffic_class; // possible value are Decimal 1, 2, 3, 4
    kal_uint8 delivery_order; // possible value are Decimal 1, 2
    kal_uint8 delivery_of_err_sdu; // possible value are Decimal 1, 2, 3
    kal_uint8 max_sdu_size; // max SDU size according to 24.008 Table 10.5.156 encoding
    kal_uint8 max_bitrate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 max_bitrate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 residual_bit_err_rate; // possible value are Decimal 1~9
    kal_uint8 sdu_err_ratio; // possible value are Decimal 1~7
    kal_uint8 transfer_delay; // possible value are Decimal 1~62
    kal_uint8 traffic_hndl_priority; // possible value are Decimal 1, 2, 3
    kal_uint8 guarntd_bit_rate_up_lnk; // possible value are Decimal 1~254
    kal_uint8 guarntd_bit_rate_down_lnk;  // possible value are Decimal 1~254
    kal_uint8 signalling_indication;
    kal_uint8 source_statistics_descriptor;
    kal_uint8 ext_max_bitrate_down_lnk;
    kal_uint8 ext_guarntd_bit_rate_down_lnk;
    kal_uint8 ext_max_bitrate_up_lnk;
    kal_uint8 ext_guarntd_bit_rate_up_lnk;
        
    kal_uint8 human_readable_delay_class; // delay_class_enum
    kal_uint8 human_readable_reliability_class; // sm_readable_reliability_class_enum
    kal_uint8 human_readable_peak_throughput; // sm_readable_peak_throughput_class_enum
    kal_uint8 human_readable_precedence_class; // sm_readable_precedence_class_enum
    kal_uint8 human_readable_mean_throughput; // sm_readable_mean_throughput_enum
    kal_uint8 human_readable_traffic_class; // sm_readable_traffic_class_enum
    kal_uint8 human_readable_delivery_order; // sm_readable_delivery_order_enum
    kal_uint8 human_readable_delivery_of_err_sdu; // sm_readable_delivery_of_err_sdu_enum
    kal_uint16 human_readable_max_sdu_size;
    kal_uint32 human_readable_max_bitrate_up_lnk;
    kal_uint32 human_readable_max_bitrate_down_lnk;
    kal_uint8 human_readable_residual_bit_err_rate; // sm_readable_residual_bit_error_rate_enum
    kal_uint8 human_readable_sdu_err_ratio; // sm_readable_sdu_err_ratio_enum
    kal_uint16 human_readable_transfer_delay; 
    kal_uint8 human_readable_traffic_hndl_priority; // sm_readable_traffic_hndl_priority_enum
    kal_uint32 human_readable_guarntd_bit_rate_up_lnk;
    kal_uint32 human_readable_guarntd_bit_rate_down_lnk;
    kal_uint8 human_readable_signalling_indication; // sm_readable_signaling_indication_enum
    kal_uint8 human_readable_source_statistics_descriptor; // sm_readable_source_statistics_descriptor_enum
    kal_uint32 human_readable_ext_max_bitrate_down_lnk;
    kal_uint32 human_readable_ext_guarntd_bit_rate_down_lnk;
    kal_uint32 human_readable_ext_max_bitrate_up_lnk;
    kal_uint32 human_readable_ext_guarntd_bit_rate_up_lnk;

} sm_em_qos_struct;


typedef struct
{
   /*
     * MTK Question: what is the index mean? Does it mean the PDP array index?
     * Response: Yes
     */
   kal_uint8   pdp_index;

   kal_uint8   nsapi; // NSAPI 
   kal_uint8    ti_value;

   /*
     * MTK Question: How many states do you need to show? Just inactive & active?
     * Response:
     * PDP status is like below
     * PDP-INACTIVE
     * PDP-ACTIVE_-PENDING
     * PDP-INACTIVE-PENDING
     * PDP-ACTIVE
     * PDP-MODIFY-PENDING
     */
     
   sm_em_mode_pdp_context_enum   pdp_context_status; 
   sm_em_mode_pdp_context_type_enum context_type;

   sm_em_mode_initiated_enum   initiated_by;

   sm_em_mode_pdp_addr_type_enum   pdp_addr_type;

   kal_uint8   ip[MAXIMUM_POSSIBLE_ADDR_LEN]; // IPv4 address or IPv6 address(not ready)
   //kal_uint8   dns1[4]; 
   //kal_uint8   dns2[4]; 

   kal_uint16 sdu_size; // Max SDU size in Bytes

   kal_uint8   apn[100];

   /*
     * MTK Question: In our current design, we clear the cause value after PDP deactivation, do you need to see the previous deactivation cause?
     * Response:
     * If MS work normal, just see the previos deactivaion cause.
     * If MS send PDP act msg to Network, MS recevie PDP reject msg from Network, then we need to see reject casue.
     */
   kal_uint8   sm_cause;          //  if applicable

   /*
     * MTK Question: Is this the neg QoS? According to 24.008 Table 10.5.156?
     * LG Response: Yes
     */

   sm_em_qos_struct em_requested_qos;
   sm_em_qos_struct em_minimum_qos;
   sm_em_qos_struct em_negotiated_qos;

   kal_uint8    pkt_flow_id;
   kal_uint8    radio_priority;   
   kal_uint16   req_n201u;
   
   #ifdef __REL7__
   sm_em_mode_selected_bcm_enum    selected_bcm ;
   #endif // __REL7__
   
} sm_em_pdp_info_struct;

/* Poying: Need to define enum so Catcher can get from database */
typedef enum{
      SM_EM_MAX_PDP_SUPPORT = 11 // nsapi 5~15
} sm_em_max_pdp_support_enum;


typedef struct{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   kal_uint8    num_of_active_pdp_context;
   sm_em_pdp_info_struct pdp; // nsapi 5~15
} em_sm_info_struct;

typedef em_sm_info_struct em_sm_nsapi5_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi6_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi7_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi8_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi9_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi10_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi11_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi12_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi13_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi14_status_ind_struct;
typedef em_sm_info_struct em_sm_nsapi15_status_ind_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16	ready_timer; //Ready timer value in SECONDS.
    kal_uint16	rau_timer;   //Periodical Routing Area Updating timer value in minute
    kal_uint8	ms_state;    //MS_NULL_STATE = 0,
                             //    MS_READY_STATE,
                             //    MS_STANDBY_STATE,
                             //    MS_FORCED_TO_STANDBY_STATE
    kal_bool is_rau_timer_running;
    kal_uint16  rau_timer_passed_time; //in minute   
    kal_uint8 attach_req_mobile_identity; //mobile identity used in last gprs attach request
#if defined(__WISDOM_EM__) || defined(__ADVANCED_EM__)
    kal_uint8 ptmsi[4]; /* P-TMSI */
    kal_uint8 attach_rej_cause; /* Attach Reject Cause, mm_cause_enum */
    kal_uint8 rau_rej_cause; /* RAU Reject Cause, mm_cause_enum */
    kal_uint8 gprs_update_status; /* gprs_update_status_enum */
    kal_uint8 cipher_algo; /* Cipher algorithm */
    kal_uint8 attach_type;/* GPRS Attach Type */
    kal_uint8 gmm_state; /* GMM state, gmm_state_enum */
    kal_uint8 gprs_attach_status; /* GPRS_DETACHED = 0, GPRS_ATTACHED = 1 */
    kal_bool     tlli_valid;
    kal_uint32   tlli;
#endif /* defined(__WISDOM_EM__) || defined(__ADVANCED_EM__) */
}em_gmm_info_ind_struct;


/* Max : 20130415 Remove for EM_MODE. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

typedef struct
{
	kal_uint32	num_reasm_failure;
} sndcp_em_info_struct;

typedef struct
{
    kal_uint8   sapi_id;
    kal_uint16  n201_ui;
    kal_uint16  n201_i;
    kal_uint16  kU;
    kal_uint16  kD;
    kal_uint32	num_fcs_error;
} llc_sapi_info_struct ;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum        em_info;
    llc_sapi_info_struct  sapi_info[2];
    kal_uint8                cipher_algo;
} em_llc_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 is_higher_pri_plmn_srch; /* indicate that if the higher priority PLMN search is performing */
    kal_uint8 hp_timeout_timer; /* higher priority PLMN search timer (6 mins per unit) */
    kal_uint8 hp_count_down_timer; /* higher priority PLMN search count down timer (6 mins per unit) */
    kal_uint8 rplmn[6]; /* RPLMN */
    kal_uint8 eq_plmn[5][6]; /* 1~5 equivalent PLMNs (6 digits for each PLMN ID) */
    kal_uint8 forbid_plmn[4][6]; /* 1~4 forbidden PLMNs (6 digits for each PLMN ID) */
#if defined(__WISDOM_EM__) || defined(__ADVANCED_EM__)
    kal_uint8 hplmn[6];
    kal_uint8 previous_rplmn[6];
    kal_uint8 requested_plmn[6];
    kal_uint8 plmn_sel_mode;
#endif
} em_nwsel_plmn_info_ind_struct;


#ifdef __UMTS_RAT__    //For MAUI, MONZA2G exclude 3G
/**
 * Remus 20080626
 * Added MEME EM info in Catcher 
 */

typedef enum
{
    MEME_EM_EVENT_TYPE1_E1G = 6,
    MEME_EM_EVENT_TYPE1_E1H,
    MEME_EM_EVENT_TYPE1_E1I,
} MemeEmInfoEventType1;

typedef enum
{
    MEME_EM_EVENT_TYPE2_E2A,
    MEME_EM_EVENT_TYPE2_E2B,
    MEME_EM_EVENT_TYPE2_E2C,
    MEME_EM_EVENT_TYPE2_E2D,
    MEME_EM_EVENT_TYPE2_E2E,
    MEME_EM_EVENT_TYPE2_E2F
} MemeEmInfoEventType2;

typedef enum
{
    MEME_EM_EVENT_TYPE3_E3A,
    MEME_EM_EVENT_TYPE3_E3B,
    MEME_EM_EVENT_TYPE3_E3C,
    MEME_EM_EVENT_TYPE3_E3D
} MemeEmInfoEventType3;
typedef struct {
    kal_uint8   MeasId;
    MemeEmInfoEventType1   EventType;
    kal_uint8   fc;
    kal_uint8   MeasQuantity; // FDD only
    kal_int16   W;            // FDD only
    kal_int16   R;            // FDD only
#ifdef __UMTS_TDD128_MODE__
    kal_int16   Threshold;    // TDD128 only
#endif
    kal_int16   Hystersis;
    kal_uint16  TimeToTrigger;
} event_1_struct;

typedef struct {
    kal_uint8   MeasId;
    MemeEmInfoEventType2   EventType; // 0: 2A, 1: 2B, 2: 2C, 3: 2D, 4: 2E, 5: 2F
    kal_uint8   fc;
#ifndef __UMTS_TDD128_MODE__      
    kal_uint8   MeasQuantity; // FDD only
    kal_int16   UsedW;        // FDD only
    kal_int16   nonUsedW;     // FDD only
#else
    kal_int16   UsedT;        // TDD128 only
#endif
    kal_int16   nonUsedT;
    kal_int16   Hystersis;
    kal_uint16  TimeToTrigger;
} event_2_struct;

typedef struct {
    kal_uint8   MeasId;
    MemeEmInfoEventType3   EventType; // 0: 3A, 1: 3B, 2: 3C, 3: 3D
    kal_uint8   fc;
    kal_int32   ThresholdOwnSystem;
    kal_int32   ThresholdOtherSystem;
#ifndef __UMTS_TDD128_MODE__      
    kal_int16   W; // FDD only
#endif    
    kal_int16   Hystersis;
    kal_uint16  TimeToTrigger;
} event_3_struct;

typedef struct {
    kal_uint8   MeasId;
    kal_uint8   TrCHId;
    kal_uint8   EventType; // 0: 4A, 1: 4B
    kal_uint8   Threshold;
    kal_uint16  TimeToTrigger;
    kal_uint16  PendingTimeAfterTrigger;
    kal_uint16  TxInteruptionAfterTrigger;
} event_4_struct;

typedef struct {
    kal_uint8   MeasId;
    kal_uint8   TrCHId;
    kal_uint16  TotalCRC;
    kal_uint16  BadCRC;
    kal_uint16  PendingTimeAfterTrigger;
} event_5_struct;

typedef struct {
    kal_uint8   MeasId;
    kal_uint8   EventType; // 0: 6A, 1: 6B, 2: 6C, 3: 6D, 4: 6E, 5: 6F
    kal_uint8   fc;
    kal_int16   TxThreshold;
    kal_uint16  TimeToTrigger;
} event_6_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_1_struct em_event_info[6];
} em_meme_event_type_1_parameter_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_2_struct em_event_info[6];
} em_meme_event_type_2_parameter_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_3_struct em_event_info[4];
} em_meme_event_type_3_parameter_info_ind_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_4_struct em_event_info[4];
} em_meme_info_event_type_4_parameter_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_5_struct em_event_info[2];
} em_meme_info_event_type_5_parameter_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_event_info;
    event_6_struct em_event_info[4];
} em_meme_info_event_type_6_parameter_struct;


typedef struct {
    kal_uint8 TrCHId;
    kal_uint32 TotalCRC;
    kal_uint32 BadCRC;
} trch_bler_struct;

typedef struct {
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_trch;
    trch_bler_struct TrCHBler[8];
} em_meme_periodic_bler_report_ind;


#if defined(__UMTS_TDD128_MODE__)
typedef struct
{    
    kal_uint16 UARFCN;
    kal_uint16 CELLPARAID; 
    kal_int32 RSCP; /* value = RSCP/4096 */
    kal_int32 ISCP[6]; /* value = ISCP/4096, timeslot 1 - 6 */ 
    kal_bool isServingCell;/* if it is KAL_TRUE, MMI or Catcher display the cell in Red*/    
} meme_umts_cell_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint16 workingFreq; 
    kal_uint8 num_cells;
    kal_uint8 supportBand; //bitmap: bit0-A Band, bit1-B Band, bit2-C Band, bit3-D Band, bit4-E Band, bit5-F Band
    kal_uint8 sinr; // 0~254, 0xff means this value is invalid
    meme_umts_cell_struct umts_cell_list[64];
} em_meme_dch_umts_cell_info_ind_struct;
#endif

#if defined(__UMTS_FDD_MODE__)
typedef struct uas_cell_plmn_id
{
    kal_uint16              mcc;
    kal_uint16              mnc;
} uas_cell_plmn_id;

/* BIT STRING URA-Identity */
typedef struct meme_umts_ura_identity
{
   kal_uint8                numBits;
   kal_uint8                stringData[2];
}
meme_umts_ura_identity;

typedef enum {
    MEME_EM_ACTIVE_SET,
    MEME_EM_INTRA_MONITORED,
    MEME_EM_INTRA_DETECTED,
    MEME_EM_INTER_MONITORED
} meme_em_umts_cell_type;

typedef struct
{    
    kal_uint16              UARFCN;
    kal_uint16              PSC;    // FDD only
    kal_int32               RSCP;   /* value = RSCP/4096 */
    kal_int32               ECN0;   /* value = ECN0/4096 */ // FDD only
    meme_em_umts_cell_type  cell_type; 
    kal_uint8               Band;
    kal_int32               RSSI;
    kal_uint32              Cell_identity;

    kal_uint8               validity;
#define MEME_UMTS_CELL_INFO_LAC_VALID 0x01
#define MEME_UMTS_CELL_INFO_RAC_VALID 0x02
#define MEME_UMTS_CELL_INFO_CID_VALID 0x04

    /* Extended Cell Info */
    kal_uint8               num_plmn_id;
    uas_cell_plmn_id        plmn_id_list[6];
    kal_uint16              lac;
    kal_uint8               rac;
    kal_uint8               num_ura_id;
    meme_umts_ura_identity  uraIdentity[8];
} meme_umts_cell_struct;

typedef struct
{
    kal_int8 tx_power; // FDD only
    kal_uint8 num_cells;
    meme_umts_cell_struct umts_cell_list[32];
} meme_em_info_umts_cell_status_struct;
#endif

typedef struct
{    
    kal_uint8 frequency_band;
    kal_uint16 arfcn;
    kal_uint8 bsic;
    kal_int16 rssi; /* value = rssi /4 */
    kal_bool verified;
} meme_gsm_cell_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8 num_cells;
    meme_gsm_cell_struct gsm_cell_list[6];
} em_meme_dch_gsm_cell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_bool with_2g_neighbor;
    kal_bool is_gsm_ncell_meas_ongoing;
} em_meme_gsm_ncell_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;		
    kal_bool with_4g_neighbor;
    kal_bool is_lte_ncell_meas_ongoing;
} em_meme_lte_ncell_info_ind_struct;
/* 20101006 
 * H-Serving cell information is added into EM */
typedef struct
{
   kal_uint16 HSDSCH_Serving_UARFCN;     /* uarfcn of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 HSDSCH_Serving_PSC;        /* psc of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_UARFCN;       /* uarfcn of E-DCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_PSC;          /* psc of E-DCH serving cell, 0xFFFF means invalid */
} meme_em_info_h_serving_cell_ind_struct;

/**
 * Gibran 20061228
 * Added Cell Status for EM in Catcher 
 * Gibran 20080627
 * Modified CSCE structure for EM in Catcher/MMI.
 */
typedef enum                     
{
   EM_3G_IN_SERV_ABOVE_S,  /* green button */
   EM_3G_IN_SERV_BELOW_S,  /* yellow button */
   EM_3G_OUT_OF_SERV,      /* orange button */
   EM_3G_NO_SERV,          /* red button */
   EM_3G_NO_CHANGE         /* no change */
} em_3g_service_status_enum;

typedef enum                     
{
   EM_3G_RRC_IDLE,  
   EM_3G_RRC_CELL_FACH,
   EM_3G_RRC_CELL_PCH,
   EM_3G_RRC_URA_PCH,
   EM_3G_RRC_CELL_DCH,
   EM_3G_RRC_INACTIVE,
   EM_3G_RRC_NO_CHANGE,
   // RRCE R7 new states   
   EM_3G_RRC_CELL_FACH_HSDPA,
   EM_3G_RRC_CELL_PCH_HSDPA_DATA,  
   EM_3G_RRC_CELL_PCH_HSDPA_PAGING,  
   EM_3G_RRC_URA_PCH_HSDPA_PAGING,
   // RRCE R8 new states 
   EM_3G_RRC_CELL_FACH_HSUPA,
   EM_3G_RRC_CELL_PCH_HSUPA_DATA,  
   EM_3G_RRC_CELL_PCH_READYtoHSPA
} em_3g_rrc_state_enum;

typedef struct
{
   em_3g_service_status_enum  service_status;               //MMI
   em_3g_rrc_state_enum      umts_rrc_state;                //MMI     
   kal_uint16        uarfcn_DL;                             //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change. */
   kal_uint16        psc;                                   //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change.*/
#ifdef __UMTS_TDD128_MODE__
   kal_uint16        workingFreq;                           //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change. */
   kal_uint16        uppch_Position;                       //MMI
   /* if 0xFFFFFFFF means Invalid, set to empty; 0xFFFFFFFE means No Change.*/
   
   kal_uint16    repetitionPeriod_dl;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionLength_dl;
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionPeriod_ul; 
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
   kal_uint16    repetitionLength_ul;   
   /* if 0xFFFF means Invalid, set to empty; 0xFFFE means No Change. */
#endif
} uas_em_3g_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   
   uas_em_3g_status  uas_3g_general_status;
} em_urr_3g_general_status_ind_struct;
#ifdef __UMTS_TDD128_MODE__
typedef enum
{
   INTRA_TR_HHO, 
   INTRA_TM_HHO,
   INTER_TR_HHO,
   INTER_TM_HHO,
   INTRA_TR_BHO,
   INTRA_TM_BHO,
   INTER_TR_BHO,
   INTER_TM_BHO,
   HHO_REVERT,
   BHO_REVERT
} em_3g_handover_type_enum; /* the enum name should be shown in MMI */

typedef struct
{
   kal_uint16   primary_uarfcn_DL;	              
   kal_uint16   working_uarfcn;	          
   kal_uint16   physicalCellId;                   

}em_3g_cell_info;

typedef struct
{
   em_3g_handover_type_enum  service_status;
   em_3g_cell_info           old_cell_info;
   em_3g_cell_info           target_cell_info;
} em_uas_handover_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   
   em_uas_handover_status  uas_3g_general_status;
} em_uas_3g_tdd128_handover_sequence_ind_struct;

#endif /*__UMTS_TDD128_MODE__*/


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info; 
} em_rrce_3g4_redir_event_ind_struct;

typedef struct
{
   kal_uint16        uarfcn_DL;     //MMI
   kal_uint16        psc;           //MMI
   kal_uint32        Sib_Scheduled; //MMI
   /* MIB      0x0001
      SB1      0x0002
      SB2      0x0004
      SIB1     0x0008
      SIB2     0x0010
      SIB3     0x0020
      SIB4     0x0040
      SIB5     0x0080
      SIB6     0x0100
      SIB7     0x0200
      SIB11    0x0400
      SIB12    0x0800
      SIB18    0x1000
      SIB16    0x4000 
      SIB5bis      0x8000
      SIB11bis 0x00010000
      SIB19 0x00020000
      SIB20 0x00040000
      */
   kal_uint32        received_Sib_Type;   //MMI
   kal_bool          is_finished;      //MMI
/*    20110524 YenChih
  *    kal_uint8 deferredSIB11 is only used in UMTS_R7 for catcher to display deferred SIB11 related information
  *                 0x00: status not change,  
  *                 0x01: deferred SIB11 is on-going, 
  *                 0x02: deferred SIB11 is finished
  */
   kal_uint8        deferredSIB11_ongoing;   //MMI
#ifdef __UMTS_TDD128_MODE__      

   kal_uint8        cell_type;             //MMI
                /*0x00 invalid (clear Cell_type)
                  0x01 r4 cell
                  0x03 DPA CELL
                  0X05 UPA CELL
                  0X07 UPA+DPA CELL
                */
#endif /*UMTS_TDD128_MODE*/
} sibe_em_sib_status;

/* Viola 20080627, sibe_em_sib_status as the discussion with Shyla,
Sib_Scheduled brings a bitmask for several SIBs, which indicate the SIBs UE needs to receive. Catcher should gray the other SIBs not contained in the variable. Sib_Scheduled would change 0~2 times during SIB collection, I suggest that Catcher could store the current Sib_Scheduled value and compare it with the latest received one. 
received_Sib_Type: This variable may contain one or several SIBs. Catcher shall mark "v" for the SIB(s) contained in this variable, but shall all keep the v of the other SIBs, which is marked by pervious "sibe_em_sib_status" messages.
is_finished: is_finished sets to True, it means that the current SIB Collection finishes. When a new collection starts, Catcher shall clean the "v" mark of all SIBs.
*/

typedef struct
{
   LOCAL_PARA_HDR
   sibe_em_sib_status      sib_status;
} sibe_em_sib_status_ind_struct;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;   /* UARFCN */  //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
   /* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI                   
   kal_int32         squal;                     //MMI               
   kal_int32         rscp;                      //MMI
#ifdef __UMTS_FDD_MODE__   
   kal_int32         ec_no;                     //MMI
#endif   
   kal_uint16        cycleLength;               //MMI
#ifdef __UMTS_FDD_MODE__   
/* number as k, value is 2k/100 in sec, float */
   kal_uint8         quality_measure;   /* 0: RSCP, 1: EcN0 */ //MMI
#endif
   /**
    * Dennis Weng 20101015
    * add band, rssi, cell_identity
    */   
   kal_uint8         band;
   kal_int32         rssi;
   kal_uint32        cell_identity;
#ifdef __UMTS_R8__
/* csg_id: 0xFFFFFFFF means not show this csg_id */
   kal_uint32        csg_id;
/* apbcr_priority: -2 means not show apbcr_priority, Sprio_search1, Sprio_search2, and Threshserv_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         sprio_search1;              //MMI
   kal_uint8         sprio_search2;              //MMI
   kal_uint8         threshserv_low;             //MMI
   kal_uint8         threshserv_low2;            //MMI, 0xFF means invalid
#endif

#if defined(__UMTS_FDD_MODE__)
   /* AT&T EM mode */
   kal_uint8         multi_plmn_count;
   plmn_struct       multi_plmn_id[6];

   kal_bool          lac_valid;
   kal_uint16        lac;

   kal_bool          rac_valid;
   kal_uint8         rac;

   kal_bool          ura_valid;
   kal_uint8         num_ura_id;
   meme_umts_ura_identity uraIdentity[8];
#endif
} csce_em_serv_cell_s_status;

typedef struct
{
    kal_uint8 multi_plmn_count;
    plmn_struct multi_plmn_id[6];
} csce_em_info_multiple_plmn_struct;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        uarfcn_DL;                 //MMI
   kal_uint16        psc;                       //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_int8          qQualmin;  /* Qualmin */   //MMI
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI     
   kal_int32         squal;                     //MMI     
   kal_int32         rscp;                      //MMI      
   kal_int32         ec_no;                     //MMI        
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;             //MMI
   kal_uint8         threshx_high;               //MMI
   kal_uint8         threshx_low;                //MMI
   kal_uint8         threshx_high2;              //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;               //MMI, 0xFF means invalid  
#endif

#if defined(__UMTS_FDD_MODE__)
   /* AT&T EM mode */
   kal_uint32        cell_identity;

   kal_bool          multi_plmn_valid;

   kal_uint8         multi_plmn_count;
   plmn_struct       multi_plmn_id[6];

   kal_bool          lac_valid;
   kal_uint16        lac;

   kal_bool          rac_valid;
   kal_uint8         rac;

   kal_bool          ura_valid;
   kal_uint8         num_ura_id;
   meme_umts_ura_identity uraIdentity[8];
#endif
} csce_em_neigh_cell_s_status;

typedef struct
{
   kal_uint8         cellidx;
   kal_uint16        arfcn;                     //MMI
   kal_uint8         bsic;                      //MMI
   kal_bool          is_bsic_verified;          //MMI
   kal_bool          is_s_criteria_satisfied;   //MMI
/* is_s_criteria_satisfied, 0: FALSE, 1: TRUE */
   kal_uint8         freq_band;                 //MMI
   /* 0: 1800Band, 1: 1900Band */
   kal_int8          qRxlevmin; /* Qrxlevmin */ //MMI
   /* the following value should be divided by 4096, the result may be float */
   kal_int32         srxlev;                    //MMI
   kal_int32         rssi;                      //MMI
#ifdef __UMTS_R8__
/* apbcr_priority: -2 means not show apbcr_priority, Threshx_high, and Threshx_low */
   kal_int8          apbcr_priority;            //MMI
   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
#endif
} csce_em_2G_neigh_cell_s_status;

typedef struct
{
   kal_uint16        earfcn;                    //MMI
   kal_uint16        pci;                       //MMI
   kal_int32         rsrp;                      //MMI
   kal_int32         rsrq;                      //MMI
   kal_int32         Treselection;              //MMI
   kal_int8          apbcr_priority;            //MMI
   
   kal_int16         qRxlevmin;                 //MMI
   kal_int8          qQualMinEUTRA;             //MMI

   kal_uint8         threshx_high;              //MMI
   kal_uint8         threshx_low;               //MMI
   kal_uint8         threshx_high2;             //MMI, 0xFF means invalid
   kal_uint8         threshx_low2;              //MMI, 0xFF means invalid
} csce_em_LTE_neigh_cell_s_status;

typedef struct
{
   LOCAL_PARA_HDR
   csce_em_serv_cell_s_status      serv_cell;
} csce_em_serv_cell_s_status_ind_struct;

typedef enum
{
  EM_UMTS_CELL,
  EM_GSM_CELL,
  EM_LTE_CELL
} em_RAT_type_enum;

#ifdef __UMTS_R8__
typedef enum
{
  EM_CLEAN_NEIGH_CELL_INFO,
  EM_UPDATE_RH_NEIGH_CELL_INFO,
  EM_UPDATE_APBCR_NEIGH_CELL_INFO
}em_neigh_cell_operation_enum;
#endif

typedef struct
{
   LOCAL_PARA_HDR 
   kal_uint8               neigh_cell_count;
#ifdef __UMTS_R8__
   em_neigh_cell_operation_enum      operation;
#endif
   em_RAT_type_enum        RAT_type;
   union
   {
      csce_em_neigh_cell_s_status      neigh_cells[16];
      csce_em_2G_neigh_cell_s_status   GSM_neigh_cells[16];
   }
   choice;
   /* for the element over neigh_cell_count, left blank */ 
} csce_em_neigh_cell_s_status_ind_struct;

typedef struct
{
   kal_uint8      cellidx;
   kal_uint8      celltype;               //MMI
   /* 1: ServCell, 2: IntraFreq NeighCell, 3: InterFreq NeighCell, 4: InterRAT NeighCell, 5: Detected NieghCell */
   kal_int32      r_value;                //MMI
   /* the value should be divided by 4096, the result may be float */
   kal_int32      Treselection;           //MMI
   /* if ServCell, it's Tresel_s; others, it's Tresel_acc */
   kal_uint8      chan_fail_type;         //MMI
   /* 0: Normal, 1: BCH failure, 2: Attempt failure, 4: MainCH failure */
} csce_em_cell_r_status;

typedef struct
{
   LOCAL_PARA_HDR 
   kal_uint8               cell_count;
   csce_em_cell_r_status   cell_r_status[9];      /* for the element over neigh_cell_count, left blank */ 
} csce_em_cell_r_status_ind_struct;

typedef struct
{
   kal_uint8      cellidx;
   kal_int32      h_value;       //MMI
   /* the value should be divided by 4096, the result may be float */     
   kal_uint8      HCS_PRIO;      //MMI
} csce_em_cell_h_status;

typedef struct
{
   LOCAL_PARA_HDR 
   kal_uint8               cell_count;
   csce_em_cell_h_status   cell_h_status[9];      /* for the element over neigh_cell_count, left blank */ 
} csce_em_cell_h_status_ind_struct;

#ifdef __UMTS_R8__
typedef struct
{
   kal_uint8      cellidx;
   kal_uint8      celltype;               //MMI
   /* 1: ServCell, 2: IntraFreq NeighCell, 3: InterFreq NeighCell, 4: InterRAT NeighCell, 5: Detected NieghCell */
   kal_int32      Treselection;           //MMI
   /* if ServCell, it's Tresel_s; others, it's Tresel_acc */
   kal_uint8      chan_fail_type;         //MMI
   /* 0: Normal, 1: BCH failure, 2: Attempt failure, 4: MainCH failure */
} csce_em_cell_apbcr_status;

typedef struct
{
   LOCAL_PARA_HDR 
   kal_uint8               cell_count;
   csce_em_cell_apbcr_status   cell_apbcr_status[16];      /* for the element over neigh_cell_count, left blank */ 
} csce_em_cell_apbcr_status_ind_struct;
#endif

#ifdef __UMTS_R8__
typedef enum
{
  _QPSK=0,			
  _16QAM,			/* 1st alphabet can not digit */
  _64QAM
}em_mod_enum;

typedef struct
{
   kal_bool	   dl_64QAM_on;
} ul1_em_hs_dsch_configuration_struct;

typedef struct
{
   kal_bool	   ul_16QAM_on;
   kal_uint8   edch_tti;
} ul1_em_edch_configuration_struct;

typedef struct
{
   kal_bool	   dtx_on;
	kal_bool	   drx_on;
} ul1_em_cpc_configuration_struct;

typedef struct
{
   kal_bool    dc_on;
   kal_uint16  dl_freq;
   kal_uint16  psc;
   kal_bool    dl_64QAM_on;
} ul1_em_secondary_hs_dsch_configuration_status_struct;

typedef struct
{
   kal_uint16  dsch_error_all;
   kal_uint16  dsch_error_new_data;
   kal_uint16  dsch_error_after_retx;
   em_mod_enum dsch_curr_mod;
   kal_uint16  dsch_code_num;
   kal_uint16  dsch_cqi_val;	
   kal_uint16  dsch_gap_ratio;
} ul1_em_primary_hs_dsch_bler_struct;

typedef struct
{
   kal_uint16  dsch_error_all;
   kal_uint16  dsch_error_new_data;
   kal_uint16  dsch_error_after_retx;
   em_mod_enum dsch_curr_mod;
   kal_uint16  dsch_code_num;
   kal_uint16  dsch_cqi_val;
   kal_uint16  dsch_gap_ratio;	
} ul1_em_secondary_hs_dsch_bler_struct;

typedef struct
{
   kal_uint16  edch_ack_cnt;
	kal_uint16  edch_gap_ratio;
} ul1_em_edch_ack_rate_struct;

/* hs_dsch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_hs_dsch_configuration_struct EmHsDschInfo;
}
em_ul1_hs_dsch_config_ind_struct;

/* edch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_edch_configuration_struct EmEdchInfo;
}
em_ul1_edch_config_ind_struct;

/* secondary_hs_dsch_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_secondary_hs_dsch_configuration_status_struct EmSecHsDschInfo;
}
em_ul1_sec_hs_dsch_config_ind_struct;


/* cpc_configuration */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_cpc_configuration_struct EmCpcInfo;
}
em_ul1_cpc_config_ind_struct;

/* primary_hs_dsch_bler*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_primary_hs_dsch_bler_struct EmPriHsDschBLER;
}
em_ul1_pri_hs_dsch_bler_ind_struct;

/* secondary_hs_dsch_bler */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_secondary_hs_dsch_bler_struct EmSecHsDschBLER;
}
em_ul1_sec_hs_dsch_bler_ind_struct;

/* edch_ack_rate */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    ul1_em_edch_ack_rate_struct EmEdchAckRate;
}
em_ul1_edch_ack_rate_ind_struct;

#endif

typedef struct
{
   LOCAL_PARA_HDR  
   /* the "sx","s_intra_search_value","s_intra_search_value",
   "s_search_hcs_value", "s_search_rat_value", 
   "s_hcs_rat_value", "s_limit_search_rat_value" 
   should be divided by 4096, the result may be float */
   kal_int32        sx;                            //MMI
   kal_bool         is_s_intra_search_valid;
   kal_int32        s_intra_search_value;          //MMI
   kal_bool         is_s_inter_search_valid;
   kal_int32        s_inter_search_value;          //MMI
   kal_bool         is_s_search_hcs_valid;
   kal_int32        s_search_hcs_value;            //MMI
   kal_bool         is_s_search_rat_valid;
   kal_int32        s_search_rat_value;            //MMI
   kal_bool         is_s_hcs_rat_valid;
   kal_int32        s_hcs_rat_value;               //MMI
   kal_bool         is_s_limit_search_rat_valid;
   kal_int32        s_limit_search_rat_value;      //MMI
   /* For meas_tgt_cells: 
      1st LSB: UMTS Intra-Freq Cells, 2nd LSB: UMTS Inter-Freq Cells, 3rd LSB: GSM Inter-RAT Cells 
      "Meas Target Type" in "Measurement Rule Status":
      0: Serv Cell only
      1: Serv with IntraFreq Cell
      2: Serv with InterFreq Cell
      3: Serv with Intra/InterFreq Cell
      4: Serv with InterRAT Cell
      5: Serv with IntraFreq/InterRAT Cell
      6: Serv with InterFreq/InterRAT Cell
      7: Serv with Intra/InterFreq/InterRAT Cell
      If the 1st&2nd LSB are all set to '0', make the "UMTS Satisfied Neighbour Cells Status" be invalid; 
      If the 3rd LSB is set to '0', make the "GSM Satisfied Neighbour Cells Status" be invalid. */
   kal_uint32       meas_tgt_cells;               //MMI

#ifdef __UMTS_R8__
/* For apbcr_enabled_type:
      1: MEAS_RULE
      2: MEAS_RULE_AND_APB_H_PRIO
      3: MEAS_RULE_AND_APB_ALL_PRIO
      If apbcr_enabled_type is 1, please do not show apbMeasTargetCells, is_gsm_apbcr_enabled, apbcr_uarfcn .
   */
   kal_uint8        apbcr_enabled_type;               //MMI
   /* For apbMeasTargetCells:
      0: None cell
      1: intraFreq Cell
      2: interFreq Cell
      3: Intra/InterFreq Cell
      4: GSM Cell
      5: intraFreq/GSM Cell
      6: interFreq/GSM Cell
      7: Intra/InterFreq/GSM Cell
      8: LTE Cell
      9: intraFreq/LTE Cell
     10: interFreq/LTE Cell
     11: intraFreq/interFreq/LTE Cell
     12: GSM/LTE Cell
     13: intraFreq/GSM/LTE Cell
     14: interFreq/GSM/LTE Cell
     15: Intra/InterFreq/GSM/LTE Cell
   */
   kal_uint32       apbMeasTargetCells;                 //MMI
   kal_bool         is_gsm_apbcr_enabled;               //MMI
#ifdef __UMTS_FDD_MODE__
   kal_uint16       apbcr_uarfcn[2];                    //MMI
#endif /* __UMTS_FDD_MODE__ */
#ifdef __UMTS_TDD128_MODE__
   kal_uint16       apbcr_uarfcn[8];                    //MMI
#endif /* __UMTS_TDD128_MODE__ */
#endif

} csce_em_meas_rule_status_ind_struct;

/* BEGIN {2013} - NEW EM Architecture */
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 multi_plmn_count;
    plmn_struct multi_plmn_id[6];
}
em_csce_multiple_plmn_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8               neigh_cell_count;
#ifdef __UMTS_R8__
   em_neigh_cell_operation_enum      operation;
#endif
   em_RAT_type_enum        RAT_type;
   union
   {
      csce_em_neigh_cell_s_status      neigh_cells[16];
      csce_em_2G_neigh_cell_s_status   GSM_neigh_cells[16];
      csce_em_LTE_neigh_cell_s_status  LTE_neigh_cells[16];  
   }
   choice;
   /* for the element over neigh_cell_count, left blank */ 
}
em_csce_neigh_cell_s_status_ind_struct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum em_info;

   /* the "sx","s_intra_search_value","s_intra_search_value",
   "s_search_hcs_value", "s_search_rat_value", 
   "s_hcs_rat_value", "s_limit_search_rat_value" 
   should be divided by 4096, the result may be float */
   kal_int32        sx;                            //MMI
   kal_bool         is_s_intra_search_valid;
   kal_int32        s_intra_search_value;          //MMI
   kal_bool         is_s_inter_search_valid;
   kal_int32        s_inter_search_value;          //MMI
   kal_bool         is_s_search_hcs_valid;
   kal_int32        s_search_hcs_value;            //MMI
   kal_bool         is_s_search_rat_valid;
   kal_int32        s_search_rat_value;            //MMI
   kal_bool         is_s_hcs_rat_valid;
   kal_int32        s_hcs_rat_value;               //MMI
   kal_bool         is_s_limit_search_rat_valid;
   kal_int32        s_limit_search_rat_value;      //MMI
   /* For meas_tgt_cells: 
      1st LSB: UMTS Intra-Freq Cells, 2nd LSB: UMTS Inter-Freq Cells, 3rd LSB: GSM Inter-RAT Cells 
      "Meas Target Type" in "Measurement Rule Status":
      0: Serv Cell only
      1: Serv with IntraFreq Cell
      2: Serv with InterFreq Cell
      3: Serv with Intra/InterFreq Cell
      4: Serv with InterRAT Cell
      5: Serv with IntraFreq/InterRAT Cell
      6: Serv with InterFreq/InterRAT Cell
      7: Serv with Intra/InterFreq/InterRAT Cell
      If the 1st&2nd LSB are all set to '0', make the "UMTS Satisfied Neighbour Cells Status" be invalid; 
      If the 3rd LSB is set to '0', make the "GSM Satisfied Neighbour Cells Status" be invalid. */
   kal_uint32       meas_tgt_cells;               //MMI

#ifdef __UMTS_R8__
/* For apbcr_enabled_type:
      1: MEAS_RULE
      2: MEAS_RULE_AND_APB_H_PRIO
      3: MEAS_RULE_AND_APB_ALL_PRIO
      If apbcr_enabled_type is 1, please do not show apbMeasTargetCells, is_gsm_apbcr_enabled, apbcr_uarfcn .
   */
   kal_uint8        apbcr_enabled_type;               //MMI
   /* For apbMeasTargetCells:
      0: None cell
      1: intraFreq Cell
      2: interFreq Cell
      3: Intra/InterFreq Cell
      4: GSM Cell
      5: intraFreq/GSM Cell
      6: interFreq/GSM Cell
      7: Intra/InterFreq/GSM Cell
      8: LTE Cell
      9: intraFreq/LTE Cell
     10: interFreq/LTE Cell
     11: intraFreq/interFreq/LTE Cell
     12: GSM/LTE Cell
     13: intraFreq/GSM/LTE Cell
     14: interFreq/GSM/LTE Cell
     15: Intra/InterFreq/GSM/LTE Cell
   */
   kal_uint32       apbMeasTargetCells;                 //MMI
   kal_bool         is_gsm_apbcr_enabled;               //MMI
#ifdef __UMTS_FDD_MODE__
   kal_uint16       apbcr_uarfcn[2];                    //MMI
#endif /* __UMTS_FDD_MODE__ */
#ifdef __UMTS_TDD128_MODE__
   kal_uint16       apbcr_uarfcn[8];                    //MMI
#endif /* __UMTS_TDD128_MODE__ */
#endif	
}
em_csce_meas_rule_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
	
    kal_uint8                 cell_count;
    csce_em_cell_apbcr_status cell_apbcr_status[16];	/* for the element over neigh_cell_count, left blank */ 
}
em_csce_apbcr_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8             cell_count;
    csce_em_cell_r_status cell_r_status[9];   /* for the element over neigh_cell_count, left blank */ 
}
em_csce_cell_r_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
	
    kal_uint8             cell_count;	
    csce_em_cell_h_status cell_h_status[9];	   /* for the element over neigh_cell_count, left blank */
}
em_csce_cell_h_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    csce_em_serv_cell_s_status serv_cell;
} em_csce_serv_cell_s_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    sibe_em_sib_status sib_status;
} em_sibe_sib_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint16 HSDSCH_Serving_UARFCN;     /* uarfcn of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 HSDSCH_Serving_PSC;        /* psc of HS-DSCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_UARFCN;       /* uarfcn of E-DCH serving cell, 0xFFFF means invalid */
   kal_uint16 EDCH_Serving_PSC;          /* psc of E-DCH serving cell, 0xFFFF means invalid */
} em_meme_dch_h_serving_cell_info_ind_struct;

typedef struct {
   LOCAL_PARA_HDR
   em_info_enum em_info;
	
   kal_uint8 num_trch;
   trch_bler_struct TrCHBler[8];
}
em_meme_dch_bler_info_ind_struct;

#if defined(__UMTS_FDD_MODE__)
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_int8 tx_power; // FDD only
    kal_uint8 num_cells;
    meme_umts_cell_struct umts_cell_list[32];
} em_meme_dch_umts_cell_info_ind_struct;
#endif

typedef struct
{
    kal_uint16 EARFCN;
    kal_uint16 PCI;
    kal_int16 RSRP;
    kal_int16 RSRQ;
} meme_lte_cell_struct;

#define MAX_REPORT_LTE_CELL_EM (32)

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;

    kal_uint8 num_cells;
    meme_lte_cell_struct lte_cell_list[32];
} em_meme_dch_lte_cell_info_ind_struct;



/* END {2013} - NEW EM Architecture */

typedef enum                     
{
   EM_TDD_MEASURE,  
   EM_FDD_MEASURE,
   EM_GSM_RSSI,
   EM_GSM_BSIC_INIT,
   EM_GSM_BSIC_CNF,
   EM_MULTI_CARRIER,
   EM_E_UTRA
} em_tgps_measure_enum;


typedef struct
{
   kal_bool          existed;  
   kal_uint8          tgpsi;  /* 1~6 */
   kal_bool          is_gap_deactive;
   /* is_gap_deactive, 0: gap is ACTIVE, 1: gap is DEACTIVE */
   em_tgps_measure_enum    measure_purpose;  
} urr_em_tgps_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;
   
   urr_em_tgps_status        tgps_status[6]; 						
     
} em_rrce_tgps_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint16        srnc;
     
} em_slce_srncid_status_ind_struct; 

typedef struct
{
   kal_uint8     RAB_ID;
   kal_int8      RB_ID;  
   kal_uint32    DL_rate;   /* the value should be divided by 1000, the result may be float, uint: kbps */
   kal_uint32    UL_rate;   /* the value should be divided by 1000, the result may be float, uint: kbps */

} slce_em_ps_data_status;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_uint8         ps_number;								
   slce_em_ps_data_status        ps_data_status[8]; 						
     
} em_slce_ps_data_rate_status_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

	/* UMAC related */
   kal_uint8	dl_mac_hspa_type;  // dl_mac_type display : 0:NA, 1:MAC-hs, 2:MAC-ehs
	kal_uint8	ul_mac_hspa_type;  // ul_mac_type display : 0:NA, 1:MAC-ees, 2:MAC-iis

	/* UL1 PHY related */
	kal_uint8 fdpch[6];           // fdpch slot format display : 0~9: SlotFormat-0 ~ SlotFormat-9, 10:NA(NotConfigured	)
	
} em_rrce_dch_state_configuration_status_ind_struct ;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

	/* eDRX related */
   kal_bool	eDRXcfgStatus;  // Note that this is config status from RRC viewpoint, not real operating status from UL1 viewpoint
	
} em_rrce_fach_state_configuration_status_ind_struct ;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum em_info;

   kal_bool	cs_over_hspa_status;  // R8 feature CS over HSPA on/off status
   
} em_rrce_cs_over_hspa_status_ind_struct;

typedef enum
{
   AMR_4_75 = 0,
   AMR_5_15,
   AMR_5_90, 
   AMR_6_70, 
   AMR_7_40, 
   AMR_7_95, 
   AMR_10_20,
   AMR_12_20,
   AMR_SID,
   GSM_EFR_SID,
   TDMA_EFR_SID,
   PDC_EFR_SID,
   RESERVE_1,
   RESERVE_2,
   RESERVE_3,
   AMR_NODATA,
   AMRWB_6_60,
   AMRWB_8_85,
   AMRWB_12_65,
   AMRWB_14_25,
   AMRWB_15_85,
   AMRWB_18_25,
   AMRWB_19_85,
   AMRWB_23_05,
   AMRWB_23_85,
   AMRWB_SID
} em_csr_SpeechCodecType;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum            em_info;
    em_csr_SpeechCodecType   ULAMRType;
    em_csr_SpeechCodecType   DLAMRType;
} em_csr_status_ind_struct;

#endif /* __UMTS_RAT__ */

typedef enum
{
   TX_ANTENNA_0,
   TX_ANTENNA_1,
   TX_ANTENNA_NUM,
   TX_ANTENNA_INVALID = 0xFF
} force_tx_ant_idx_enum;

typedef enum _force_tx_ant_cmd_type_e
{
   SET_FORCE_TX_ANT  = 0,
   READ_FORCE_TX_ANT = 1
} force_tx_ant_cmd_type_e;

typedef struct _l4cul1_force_tx_ant_req_struct
{
   LOCAL_PARA_HDR   
   force_tx_ant_cmd_type_e cmd_type;
   kal_bool enable_force_tx_ant;
   force_tx_ant_idx_enum force_tx_ant_idx;

} l4cl1_force_tx_ant_req_struct,
  l4cul1_force_tx_ant_req_struct,
  l4ctl1_force_tx_ant_req_struct,
  l4cel1_force_tx_ant_req_struct;

typedef struct _l4cul1_force_tx_ant_cnf_struct
{
   LOCAL_PARA_HDR
   force_tx_ant_cmd_type_e cmd_type;
   kal_bool result;
   kal_bool enable_force_tx_ant;
   force_tx_ant_idx_enum force_tx_ant_idx;
   
} l4cl1_force_tx_ant_cnf_struct,
  l4cul1_force_tx_ant_cnf_struct,
  l4ctl1_force_tx_ant_cnf_struct,
  l4cel1_force_tx_ant_cnf_struct;

/**************************************************************************
  * Video Telephony (3G324M) - Engineer Mode
  *
  * Notes: Following structures are maintained by VT task                                               
  * Meggie: 2007/10/05:  Add VT EM related structures     
  **************************************************************************/
/***************************** VT EM Config  ********************************/
typedef enum{
    VT_EM_DATA_TYPE_INVALID = -1,
    VT_EM_DATA_TYPE_AUDIO = 0,
    VT_EM_DATA_TYPE_VIDEO
}vt_em_channel_data_type;

typedef struct{
    LOCAL_PARA_HDR
    vt_em_config_struct em_config;
}l4c_vt_em_set_config_req_struct;   /* MSG: MSG_ID_L4C_VT_EM_SET_CONFIG_REQ */

typedef struct{
    LOCAL_PARA_HDR
    vt_em_config_struct em_config;
}l4c_vt_em_get_config_cnf_struct;   /* MSG: MSG_ID_L4C_VT_EM_GET_CONFIG_CNF */


/****************************  VT EM Display  ********************************/
/* Radvision strucuture dependent */
typedef enum{
    VT_EM_CALL_STATE_INIT = -1,
    VT_EM_CALL_STATE_SYNCHRONIZED = 0,
    VT_EM_CALL_STATE_CONNECTED,
    VT_EM_CALL_STATE_CONNECTEDCHANNELS,
    VT_EM_CALL_STATE_IDLE,
    VT_EM_CALL_STATE_RESETTING,
    VT_EM_CALL_STATE_LOSTSYNC
}vt_em_call_state_choice; /* Refer to Rv3G324mCallState type */

typedef enum
{
    VT_EM_CODEC_TYPE_Unknown = -1,
    VT_EM_CODEC_TYPE_Amr,
    VT_EM_CODEC_TYPE_Mpeg4,
    VT_EM_CODEC_TYPE_H264,
    VT_EM_CODEC_TYPE_H239Control,
    VT_EM_CODEC_TYPE_H239ExtendedVideo,
    VT_EM_CODEC_TYPE_G7221,
    VT_EM_CODEC_TYPE_G726,
    VT_EM_CODEC_TYPE_H324AnnexI,
    VT_EM_CODEC_TYPE_SessionReset,
    VT_EM_CODEC_TYPE_G7222,
    VT_EM_CODEC_TYPE_G7231,
    VT_EM_CODEC_TYPE_H263,
    VT_EM_CODEC_TYPE_G711,
    VT_EM_CODEC_TYPE_G722,
    VT_EM_CODEC_TYPE_G729,
    VT_EM_CODEC_TYPE_H249NavigationKey,
    VT_EM_CODEC_TYPE_H249SoftKeys,
    VT_EM_CODEC_TYPE_H249PointingDevice,
    VT_EM_CODEC_TYPE_H249ModalInterface,
    VT_EM_CODEC_TYPE_Last
} vt_em_codec_type;

/* Radvision strucuture independent */
typedef enum{
    VT_EM_MASTER_SLAVE_STATUS_INVALID = -1,
    VT_EM_SLAVE = 0,
    VT_EM_MASTER
}vt_em_master_slave_status_choice;

typedef enum{
    VT_EM_RETRANSMISSION_PROTOCOL_INVALID = -1,
    VT_EM_RETRANSMISSION_PROTOCOL_SRP = 0,
    VT_EM_RETRANSMISSION_PROTOCOL_NSRP,
    VT_EM_RETRANSMISSION_PROTOCOL_WNSRP
}vt_em_retransmission_protocol_choice;

typedef enum{
    VT_EM_RESOLUTION_INVALID = -1,
    VT_EM_RESOLUTION_SQCIF = 0,
    VT_EM_RESOLUTION_QCIF,
    VT_EM_RESOLUTION_CIF
}vt_em_video_resolution_choice;

typedef enum{
    VT_EM_H223_AL_TYPE_UNKNOWN = -1,
    VT_EM_H223_AL_TYPE_1 = 0,
    VT_EM_H223_AL_TYPE_2,
    VT_EM_H223_AL_TYPE_3
}vt_em_al_type;

typedef struct{
    kal_uint16 lcn;
    kal_uint8   is_chan_duplex;
    vt_em_codec_type   codec_type;
    vt_em_video_resolution_choice  resolution_choice;
    vt_em_al_type forward_al;
    kal_int32   max_sdu_size;
}vt_em_video_channel_info_struct;

typedef struct{
    kal_uint16 lcn;
    kal_uint8   is_chan_duplex;
    vt_em_codec_type   codec_type;
    vt_em_al_type forward_al;
    kal_int32   max_sdu_size;
}vt_em_audio_channel_info_struct;

typedef enum{
    VT_EM_RP_UNKNOWN = -1,
    VT_EM_RP_COMMAND = 0,
    VT_EM_RP_RESPONSE
}vt_em_xSRP_data_type;

typedef struct{
    kal_uint8 sq;
    vt_em_xSRP_data_type type;
}vt_em_outgoing_xSRP;

typedef struct{
    kal_uint8 sq;
    vt_em_xSRP_data_type type;
}vt_em_incoming_xSRP;

typedef struct{        
        kal_uint32 vt_csr_DL_Q_frame_num;
        kal_uint32 vt_csr_UL_Q_frame_num;
        kal_uint32 vt_MED_DL_Q_frame_num;
        kal_uint32 vt_MED_DL_Q_state;

        kal_uint32 vt_DL_video_frame_num;
        kal_uint32 vt_DL_video_frame_size;
        kal_uint32 vt_DL_video_I_frame_num;
        kal_uint32 vt_DL_video_P_frame_num;

        kal_uint32 vt_DL_audio_frame_num;
        kal_uint32 vt_DL_audio_frame_size;
        
        kal_uint32 vt_UL_video_frame_num;
        kal_uint32 vt_UL_video_frame_size;
        kal_uint32 vt_UL_video_drop_frame_num;
        kal_uint32 vt_UL_video_drop_frame_size;

        kal_uint32 vt_UL_audio_frame_num;
        kal_uint32 vt_UL_audio_frame_size;
        kal_uint32 vt_UL_audio_drop_frame_num;
        kal_uint32 vt_UL_audio_drop_frame_size;

        kal_uint32 vt_UL_csr_size;
        kal_uint32 vt_UL_csr_num;
        kal_uint32 vt_DL_csr_size;
        kal_uint32 vt_DL_csr_num;

        kal_uint32 vt_downlink_mc_tbl[16];  /* # pkts using this mc entry */
        kal_uint32 vt_uplink_mc_tbl[16];

        kal_uint32 vt_ra_add_failures;
        kal_uint32 vt_incoming_audio_crc_errors;
        kal_uint32 vt_incoming_video_crc_errors;
        kal_uint32 vt_incoming_control_crc_errors;
        kal_uint32 vt_incoming_control_total_packets;
}vt_em_statistic_info_struct;

typedef struct{
    LOCAL_PARA_HDR
    em_info_enum em_info;
}l4cvt_em_display_ind_struct;   /* MSG: VT to L4C */
/************************** VT EM Definition End  *****************************/

/* __UL2_EM_MODE__ */
#if defined(__UMTS_RAT__)
typedef struct							
{								
    kal_uint16                      max_usage_kbytes;          /*Maximum used size of the pool, <= 999*/
    kal_uint16                      avg_usage_kbytes;           /*Average used size of the pool, <= 999*/
} adm_pool_info_struct;

typedef struct							
{		
    /*UMAC new EM Arch*/		
    adm_pool_info_struct      dl_adm_pool_info; /*dl_adm_pool_info represent the info of  DL ADM POOl 1*/
    adm_pool_info_struct      ul_adm_pool_info[4];/* ul_adm_pool_info[0] ~ ul_adm_pool_info[2] 
                                              represent the info of  UL ADM POOl 1 ~ 3 and 
                                              ul_adm_pool_info[3] represent the info TOTAL UL ADM POOL*/
} ul2_em_adm_pool_status_ind_struct;					
 							
typedef struct
{
	kal_uint8				num_trch;
	trch_bler_struct  		TrCHBler[8];
}ul2_em_3g_bler_ind_struct;

 							
typedef enum 							
{								
    Invalid,                                        /*show blank */				
    No_Modify,                                   /*show "=" */				
    Add_Queue,                                  /*show "V" */				
    Delete_Queue,                                /*show "X" */				
    Reconfigure_T1,                              /*show "T1" */				
    Reconfigure_WindowSize,                   /*show "WS" */				
    Reconfigure_T1_WindowSize,               /*show "T1_WS" */			
    Reconfigure_C_T,                          /*show "C_T"*/				
} reconfigure_operation_E;						
	
typedef struct							
{				
    reconfigure_operation_E               reconfig_info[8];         /* reconfiguration operation of the Queue 0 ~ 7 */
} ul2_em_hsdsch_reconfig_status_ind_struct;					
typedef struct
{
    kal_uint16           rx_mac_data_rate; 		/* kbps, <=2800*/
   	kal_uint16           rx_pdcp_data_rate;  	/* kbps, <= 2800*/
    kal_uint16           tx_mac_data_rate;  	/*kbps, <=400*/
    kal_uint16       	 tx_pdcp_data_rate;      /*kbps, <=400*/
} ul2_em_ps_data_rate_status_ind_struct;

typedef enum
{	
    URLC_ESTABLISH,               //display "EST"
    URLC_REESTABLISH,           //display "REEST"
    URLC_RECONFIG,                //display "RECFG"
    URLC_RELEASE,                   //display "REL"
    URLC_SUSPEND,                  //display "SUSPD"
    URLC_RESUME,                    //display "RES"
    URLC_RESET,                        //display "RST"
    URLC_DISCARD                   //display "DISCD"
} RLC_ACTION_INFO; 

typedef struct			
{				
    kal_bool                  is_srb;         // if TRUE, display "S", else display "U"
    kal_uint8                 cn_domain;  // for 0, display "CS"; for 1, display "PS"; for 2, display "ALL" 
} ul2_em_rb_info_struct; 		
				
typedef struct			
{				
    kal_uint8                  rlc_mode;   //for 1, display "TM"; for 2, display "UM"; for 3, display "AM", other "Error"
    kal_uint8                  direction;    //for 1, display "UL"; for 2, display "DL"; for 3, display "Both", other "Error"
} ul2_em_rlc_info_struct; 		

typedef struct			
{				
    kal_uint16              pdu_Size;    //display the value   
    kal_uint16              tx_window_size;  //display the value, range [1, 2048] 
    kal_uint16              rx_window_size;   //display the value, range[1, 2048] 
    kal_uint8               discard_mode;    //value is 0/1/2/3, display the value 
    kal_uint16              discard_value;    //display the value, range [0, 9999]
} ul2_em_rlc_parameter_struct; 		
				
typedef struct			
{	
    kal_int8                        rb_id;        // display the value, range [-5, 32]
    RLC_ACTION_INFO                 rlc_action; 	
    ul2_em_rb_info_struct           rb_info; 	
    ul2_em_rlc_info_struct          rlc_info; 	
    ul2_em_rlc_parameter_struct     rlc_parameter;
    kal_bool                        flush_data_indicator;    //if TRUE, display "Flush", else show blank
    kal_uint8                       reset_cause;                //value is 0/1/2, display the value
} ul2_em_urlc_event_status_ind_struct;	

/*UMAC new EM Arch*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_adm_pool_status_ind_struct ul2_em_adm_pool_status_ind_struct_info;
} em_ul2_adm_pool_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_ps_data_rate_status_ind_struct ul2_em_ps_data_rate_status_ind_struct_info;
} em_ul2_ps_data_rate_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_hsdsch_reconfig_status_ind_struct ul2_em_hsdsch_reconfig_status_ind_struct_info;
} em_ul2_hsdsch_reconfig_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_urlc_event_status_ind_struct ul2_em_urlc_event_status_ind_struct_info;
} em_ul2_urlc_event_status_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_3g_bler_ind_struct ul2_em_periodic_bler_report_ind_info;
} em_ul2_3g_bler_ind_struct;

/***HSUPA SI***/
typedef struct
{
   kal_uint32                       time;
   kal_uint8                        SNPL;
   kal_uint8                        UPH;
   kal_uint8                        TEBS;
   kal_uint8                        HLBS;
   kal_uint8                        HLID;
   kal_bool                         isERUCCH;
}ul2_em_hsupa_si_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    ul2_em_hsupa_si_ind_struct ul2_em_hsupa_si_ind_info;
}em_ul2_hsupa_si_ind_struct;
/***HSUPA SI***/


#endif

/**************************************************************************
  * Here is the ERRC related EM definition
  *
  * Notes: ERRC structures is defined here                                               
  * Michael: 2013/05/10:  Add ERRC EM related structures     
  **************************************************************************/
/********************* begin of ERRC definition ****************************/
typedef struct
{
    kal_uint16 earfcn;
    kal_uint16 pci;    
    kal_uint32 csg_id;    
}em_errc_csg_info_struct;

#define EM_ERRC_MAX_AUTOS_CSG_CELL_NUM 10

typedef struct
{
    kal_uint8               num_cells;
    em_errc_csg_info_struct detected_csg_cell[EM_ERRC_MAX_AUTOS_CSG_CELL_NUM];
}em_errc_autos_info_struct;

typedef enum
{
    EM_ERRC_CARRS_TRIG_TYPE_NAS,
    EM_ERRC_CARRS_TRIG_TYPE_AS,
    EM_ERRC_CARRS_TRIG_TYPE_IRAT    
}em_errc_carrs_trigger_type_enum;

typedef enum
{
    EM_ERRC_CARRS_TYPE_PLMN_LIST,
    EM_ERRC_CARRS_TYPE_CSG_LIST,
    EM_ERRC_CARRS_TYPE_FINGER_PRINT,
    EM_ERRC_CARRS_TYPE_MCC_LEARNING,
    EM_ERRC_CARRS_TYPE_BACKGROUND_SEARCH,
    EM_ERRC_CARRS_TYPE_AUTO_SEARCH,
    EM_ERRC_CARRS_TYPE_OOS
}em_errc_carrs_type_enum;

typedef struct
{
    em_errc_carrs_trigger_type_enum trigger_type;
    em_errc_carrs_type_enum         carrs_type;    
}em_errc_carrs_event_struct;

typedef enum
{
    EM_ERRC_SIB_EVENT_3H_TIMEOUT,
    EM_ERRC_SIB_EVENT_SIB_MODIFY,
    EM_ERRC_SIB_EVENT_PWS
}em_errc_sib_event_enum;

typedef enum
{
    EM_ERRC_MOB_TYPE_CR,
    EM_ERRC_MOB_TYPE_REDT,
    EM_ERRC_MOB_TYPE_CCO,
    EM_ERRC_MOB_TYPE_HO,
    EM_ERRC_MOB_TYPE_REEST    
}em_errc_mob_type_enum;

typedef enum
{
    EM_ERRC_MOB_DIR_INTRA_LTE,
    EM_ERRC_MOB_DIR_TO_LTE,
    EM_ERRC_MOB_DIR_FROM_LTE
}em_errc_mob_dir_enum;

typedef struct
{
    em_errc_mob_type_enum           mob_type;
    em_errc_mob_dir_enum            mob_dir;    
}em_errc_mob_event_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
}em_errc_mob_meas_info_ind_struct;

typedef enum
{
    EM_ERRC_RCM_SIM_STS_REMOVED,
    EM_ERRC_RCM_SIM_STS_INVALID_BY_NAS,
    EM_ERRC_RCM_SIM_STS_VALID    
}em_errc_rcm_sim_sts_enum;

typedef enum
{
    EM_ERRC_SYS_SIB_RX_STS_IDLE,
    EM_ERRC_SYS_SIB_RX_STS_WAIT,
    EM_ERRC_SYS_SIB_RX_STS_CMPL,
    EM_ERRC_SYS_SIB_RX_STS_STORED    
}em_errc_sys_sib_rx_sts_enum;

typedef struct
{
    kal_bool                    is_rxing;
    kal_uint32                  earfcn;
    kal_uint16                  pci;
    em_errc_sys_sib_rx_sts_enum mib_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib1_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib2_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib3_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib4_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib5_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib6_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib7_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib9_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib10_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib11_rx_sts;
    em_errc_sys_sib_rx_sts_enum sib12_rx_sts;
}em_errc_sib_rx_info_struct;

/*MSG_ID_EM_ERRC_AUTOS_CSG_INFO_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_autos_info_struct autos_info;
}em_errc_autos_csg_info_ind_struct;

/*MSG_ID_EM_ERRC_CARRS_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_carrs_event_struct carrs_evt;
}em_errc_carrs_event_ind_struct;


/*MSG_ID_EM_ERRC_SIB_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_sib_event_enum sib_evt;
}em_errc_sib_event_ind_struct;


/*MSG_ID_EM_ERRC_MOB_EVENT_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_mob_event_struct mob_evt;
}em_errc_mob_event_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    kal_bool                     key_chg_ind;
    //kal_uint32                   ul_nas_cnt;
    kal_uint8                    ncc;
    kal_uint8                      int_algo;
    kal_uint8                      enc_algo;
    //kal_uint8                    smc_maci[4];
    //kal_uint8                    gen_maci[4];
    //kal_uint8                    short_maci[2];
    //kal_uint8                    kasme[32];
    //kal_uint8                    kenb[32];
}em_errc_sec_param_ind_struct;

typedef enum
{
    ERRC_REEST_CAUSE_LTE_HO_FAIL,
    ERRC_REEST_CAUSE_LTE_MFROM_FAIL,
    ERRC_REEST_RLC_ACK_TIMEOUT,
    ERRC_REEST_SIB_UPDT_FAIL,
    ERRC_REEST_CAUSE_L1_RLF,
    ERRC_REEST_CAUSE_MAC_RLF,
    ERRC_REEST_CAUSE_RLC_UL_MAX_RLF,
    ERRC_REEST_CAUSE_RLC_DL_MAX_RLF,
    ERRC_REEST_CAUSE_RLC_UL_DL_MAX_RLF,
    ERRC_REEST_CAUSE_INTECHK_FAIL,
    ERRC_REEST_CAUSE_RECONF_FAIL,
    ERRC_REEST_CAUSE_PDCP_RLF,
    ERRC_REEST_CAUSE_DISABLE_B39,
    ERRC_REEST_CAUSE_GENERAL
}em_errc_reest_info_cause_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_reest_info_cause_enum cause;
}em_errc_reest_info_ind_struct;

typedef enum
{
    ERRC_NORMAL_RECONF,
    ERRC_INTRA_CEL_HO,
    ERRC_INTER_CEL_HO,
    ERRC_INTER_RAT_HO
}em_errc_reconf_info_type_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_reconf_info_type_enum reconf_type;
    kal_bool                      is_cell_info_valid;
    kal_uint32                    earfcn;
    kal_uint16                    pci;
    kal_uint16                    crnti;
    kal_uint32                    t311;
    kal_uint32                    t301;    
    kal_uint32                    t304;
}em_errc_reconf_info_ind_struct;
typedef enum
{
    //This enum must be consistent with errc_procedure_id_enum
    EM_ERRC_PROC_EST,
    EM_ERRC_PROC_RECONF_RR_MEAS_CONFIG,
    EM_ERRC_PROC_RECONF_INTRALTEMOBILITY,
    EM_ERRC_PROC_REEST,
    EM_ERRC_PROC_INITIAL_SEC,
    EM_ERRC_UE_CAPABILITY,
    EM_ERRC_COUNTER_CHECK,
    EM_ERRC_UE_INFORMATION,
    EM_ERRC_PROC_IRAT_HO_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_HO_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_CCO_FROM_LTE,
    EM_ERRC_PROC_IRAT_CR_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_CR_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_REDIR_FROM_LTE_TO_UMTS,
    EM_ERRC_PROC_IRAT_REDIR_FROM_LTE_TO_GSM,
    EM_ERRC_PROC_IRAT_HO_TO_LTE,
    EM_ERRC_PROC_IRAT_CCO_TO_LTE,
    EM_ERRC_PROC_IRAT_CR_TO_LTE,
    EM_ERRC_PROC_IRAT_REDIR_TO_LTE,
    EM_ERRC_PROC_INTRA_REDIR
}em_errc_delay_proc_enum;

typedef struct
{
		LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_delay_proc_enum delay_proc_id;
    kal_uint32              delay_time;
}em_errc_over_proc_delay_warning_ind_struct;

typedef enum
{
	  EM_ERRC_SUCCESS_RATE_KPI_INTRA_LTE_CR,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G3_CR,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G2_CR,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G4_CR,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_2G4_CR,
	  
	  EM_ERRC_SUCCESS_RATE_KPI_INTRA_CELL_HO,
	  EM_ERRC_SUCCESS_RATE_KPI_INTER_CELL_HO,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G3_HO,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_4G2_HO,
	  EM_ERRC_SUCCESS_RATE_KPI_IRAT_3G4_HO,
	  
}em_errc_success_rate_kpi_proc_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_success_rate_kpi_proc_enum proc_id;
    kal_uint32  attempt;
    kal_uint32  success;
}em_errc_success_rate_kpi_ind_struct;

typedef enum
{
    EM_ERRC_ON_DUARTION_PS1,
    EM_ERRC_ON_DUARTION_PS2,
    EM_ERRC_ON_DUARTION_PS3,
    EM_ERRC_ON_DUARTION_PS4,
    EM_ERRC_ON_DUARTION_PS5,
    EM_ERRC_ON_DUARTION_PS6,
    EM_ERRC_ON_DUARTION_PS8,
    EM_ERRC_ON_DUARTION_PS10,
    EM_ERRC_ON_DUARTION_PS20,
    EM_ERRC_ON_DUARTION_PS30,
    EM_ERRC_ON_DUARTION_PS40,
    EM_ERRC_ON_DUARTION_PS50,
    EM_ERRC_ON_DUARTION_PS60,
    EM_ERRC_ON_DUARTION_PS80,
    EM_ERRC_ON_DUARTION_PS100,
    EM_ERRC_ON_DUARTION_PS200,

    EM_ERRC_ON_DUARTION_INVALID = 0xFFFFFFFF,
}em_errc_on_duration_timer_enum;

typedef enum
{
    EM_ERRC_DRX_INACTIVITY_PS1,
    EM_ERRC_DRX_INACTIVITY_PS2,
    EM_ERRC_DRX_INACTIVITY_PS3,
    EM_ERRC_DRX_INACTIVITY_PS4,
    EM_ERRC_DRX_INACTIVITY_PS5,
    EM_ERRC_DRX_INACTIVITY_PS6,
    EM_ERRC_DRX_INACTIVITY_PS8,
    EM_ERRC_DRX_INACTIVITY_PS10,
    EM_ERRC_DRX_INACTIVITY_PS20,
    EM_ERRC_DRX_INACTIVITY_PS30,
    EM_ERRC_DRX_INACTIVITY_PS40,
    EM_ERRC_DRX_INACTIVITY_PS50,
    EM_ERRC_DRX_INACTIVITY_PS60,
    EM_ERRC_DRX_INACTIVITY_PS80,
    EM_ERRC_DRX_INACTIVITY_PS100,
    EM_ERRC_DRX_INACTIVITY_PS200,
    EM_ERRC_DRX_INACTIVITY_PS300,
    EM_ERRC_DRX_INACTIVITY_PS500,
    EM_ERRC_DRX_INACTIVITY_PS750,
    EM_ERRC_DRX_INACTIVITY_PS1280,
    EM_ERRC_DRX_INACTIVITY_PS1920,
    EM_ERRC_DRX_INACTIVITY_PS2560,

    EM_ERRC_DRX_INACTIVITY_INVALID = 0xFFFFFFFF,
}em_errc_drx_inactivity_timer_enum;

typedef enum
{
    EM_ERRC_DRX_RETX_TIMER_PS1,
    EM_ERRC_DRX_RETX_TIMER_PS2,
    EM_ERRC_DRX_RETX_TIMER_PS4,
    EM_ERRC_DRX_RETX_TIMER_PS6,
    EM_ERRC_DRX_RETX_TIMER_PS8,
    EM_ERRC_DRX_RETX_TIMER_PS16,
    EM_ERRC_DRX_RETX_TIMER_PS24,
    EM_ERRC_DRX_RETX_TIMER_PS33,

    EM_ERRC_DRX_RETX_TIMER_INVALID = 0xFFFFFFFF,
}em_errc_drx_retx_timer_enum;

typedef enum
{
    EM_ERRC_LONG_DRX_CYCLE_10,
    EM_ERRC_LONG_DRX_CYCLE_20,
    EM_ERRC_LONG_DRX_CYCLE_32,
    EM_ERRC_LONG_DRX_CYCLE_40,
    EM_ERRC_LONG_DRX_CYCLE_64,
    EM_ERRC_LONG_DRX_CYCLE_80,
    EM_ERRC_LONG_DRX_CYCLE_128,
    EM_ERRC_LONG_DRX_CYCLE_160,
    EM_ERRC_LONG_DRX_CYCLE_256,
    EM_ERRC_LONG_DRX_CYCLE_320,
    EM_ERRC_LONG_DRX_CYCLE_512,
    EM_ERRC_LONG_DRX_CYCLE_640,
    EM_ERRC_LONG_DRX_CYCLE_1024,
    EM_ERRC_LONG_DRX_CYCLE_1280,
    EM_ERRC_LONG_DRX_CYCLE_2048,
    EM_ERRC_LONG_DRX_CYCLE_2560,

    EM_ERRC_LONG_DRX_CYCLE_INVALID = 0xFFFFFFFF,
}em_errc_long_drx_cycle_enum;

typedef enum
{
    EM_ERRC_SHORT_DRX_CYCLE_2,
    EM_ERRC_SHORT_DRX_CYCLE_5,
    EM_ERRC_SHORT_DRX_CYCLE_8,
    EM_ERRC_SHORT_DRX_CYCLE_10,
    EM_ERRC_SHORT_DRX_CYCLE_16,
    EM_ERRC_SHORT_DRX_CYCLE_20,
    EM_ERRC_SHORT_DRX_CYCLE_32,
    EM_ERRC_SHORT_DRX_CYCLE_40,
    EM_ERRC_SHORT_DRX_CYCLE_64,
    EM_ERRC_SHORT_DRX_CYCLE_80,
    EM_ERRC_SHORT_DRX_CYCLE_128,
    EM_ERRC_SHORT_DRX_CYCLE_160,
    EM_ERRC_SHORT_DRX_CYCLE_256,
    EM_ERRC_SHORT_DRX_CYCLE_320,
    EM_ERRC_SHORT_DRX_CYCLE_512,
    EM_ERRC_SHORT_DRX_CYCLE_640,

    EM_ERRC_SHORT_DRX_CYCLE_INVALID = 0xFFFFFFFF,
}em_errc_short_drx_cycle_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_on_duration_timer_enum on_duration_timer_index;
    em_errc_drx_inactivity_timer_enum drx_inactivity_timer_index;
    em_errc_drx_retx_timer_enum drx_retx_timer_index;
    em_errc_long_drx_cycle_enum long_drx_cycle_index;
    em_errc_short_drx_cycle_enum short_drx_cycle_index;
    kal_uint8 drx_short_cycle_timer; /* 1-16; invalid: 0xFF */
    kal_uint16 drx_start_offset; /* 0 - 2559; Invalid: 0xFFFF */
}em_errc_config_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
   em_errc_rcm_sim_sts_enum   sim_sts;
}em_errc_rcm_sim_sts_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
   em_errc_sib_rx_info_struct   sib_rx_info[3]; /*Serving BCCH, Neighbor BCCH1, Neighbor BCCH2*/
}em_errc_sys_sib_rx_sts_info_ind_struct;

typedef enum
{
    ERRC_INITIAL,
    ERRC_STANDBY,
    ERRC_IDLE,
    ERRC_CONNECTED,
    ERRC_FLIGHT,
    ERRC_IDLE_IRSUS,
    ERRC_CONN_IRSUS
}em_errc_state_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    em_errc_state_enum errc_sts;
}em_errc_state_ind_struct;


/*MSG_ID_EM_LTE_SUPPORTED_BAND_INFO_IND*/
typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    kal_uint8    num_supported_band;
    kal_uint8    supported_band[64];
}em_lte_supported_band_info_ind_struct;


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    kal_bool with_3g_neighbor;
    kal_bool with_2g_neighbor;
}em_errc_serv_ir_neighbor_info_ind_struct;

typedef enum
{
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_GSM_R8,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_UMTS_R8,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_GSM_R9_LATER,
    EM_ERRC_EVENT_REDIR_FROM_LTE_TO_UMTS_R9_LATER
}em_errc_ir_redir_event_enum;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    em_errc_ir_redir_event_enum redir_event;
    kal_bool is_csfb_ongoing;
}em_errc_ir_redir_event_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum em_info;
    
    kal_bool utran_meas_cfg;
    kal_bool geran_meas_cfg;
}em_errc_irat_meas_cfg_ind_struct;

/********************* end of ERRC definition ****************************/


/********************* begin of EMM definition ****************************/

typedef enum
{
    EM_EMM_EU1_UPDATE = 0,
    EM_EMM_EU2_NOT_UPDATE,
    EM_EMM_EU3_ROAMING_NOT_ALLOWED
} em_emm_update_status_enum;

typedef enum
{
    EM_EMM_SIM_REMOVE,
    EM_EMM_SIM_INVALID,
    EM_EMM_SIM_VALID,
} em_emm_sim_status_enum;

typedef enum
{
    EM_EMM_TIN_DELETED    = 0,
    EM_EMM_TIN_PTMSI,
    EM_EMM_TIN_RAT_RELATED_TMSI,
    EM_EMM_TIN_GUTI
} em_emm_tin_enum;

typedef struct
{
    plmn_struct  plmn_id;
    kal_uint8   mme_gid[2];
    kal_uint8   mme_code;
    kal_uint8   mtmsi[4];
} em_emm_guti_struct;

typedef enum
{
    EM_ECM_IDLE=0,
    EM_ECM_CONNECTED
}em_emm_ecm_status_enum;

typedef enum
{
    EM_NORMAL_CELL    = 0,
    EM_CSG_CELL,
    EM_HYBRID_CELL
} em_csg_access_mode_enum;

typedef enum
{
    EM_DUPLEX_TYPE_FDD    = 0,
    EM_DUPLEX_TYPE_TDD,
    EM_DUPLEX_TYPE_UNKNOWN
} em_lte_duplex_type_enum;

typedef enum
{
    EM_TYPE_NONE                    = 0,
    EM_TYPE_SERVICE_REQ,
    EM_TYPE_EXTENDED_SERVICE_REQ,
    EM_TYPE_MAX
} em_sr_type_enum;

typedef enum
{
    EM_CAUSE_MO_SIGNAL              = 0,
    EM_CAUSE_MO_DATA,
    EM_CAUSE_MT,
    EM_CAUSE_EMERGENCY,
    EM_CAUSE_INVALID
} em_sr_cause_enum;

typedef enum
{
    EM_MO_CSFB_TYPE_INVALID         = 0,
    EM_MO_CSFB_TYPE_NORMAL_CALL,
    EM_MO_CSFB_TYPE_EMERGENCY_CALL,
    EM_MO_CSFB_TYPE_SS,
    EM_MO_CSFB_TYPE_LCS,
    EM_MO_CSFB_TYPE_RESERVED
} em_mo_csfb_cause_enum;

typedef enum
{
    EM_MT_CSFB_PAGING_ID_INVALID    = 0,
    EM_MT_CSFB_PAGING_ID_IMSI,
    EM_MT_CSFB_PAGING_ID_TMSI
} em_mt_csfb_paging_id_enum;

typedef enum
{
    EM_EMM_CAUSE_CAUSE_NONE = 0x00,
    EM_EMM_CAUSE_IMSI_UNKNOWN_IN_HSS    = 0x02,
    EM_EMM_CAUSE_ILLEGAL_UE    = 0x03,
    EM_EMM_CAUSE_IMEI_NOT_ACCEPTED    = 0x05,
    EM_EMM_CAUSE_ILLEGAL_ME    = 0x06,
    EM_EMM_CAUSE_EPS_NOT_ALLOWED    = 0x07,
    EM_EMM_CAUSE_EPS_NON_EPS_NOT_ALLOWED    = 0x08,
    EM_EMM_CAUSE_UE_ID_NOT_DERIVED_BY_NW    = 0x09,
    EM_EMM_CAUSE_IMPLICIT_DETACH    = 0x0a,
    EM_EMM_CAUSE_PLMN_NOT_ALLOWED    = 0x0b,
    EM_EMM_CAUSE_TA_NOT_ALLOWED    = 0x0c,
    EM_EMM_CAUSE_ROAMING_NOT_ALLOWED_IN_TA    = 0x0d,
    EM_EMM_CAUSE_EPS_NOT_ALLOWED_IN_PLMN    = 0x0e,
    EM_EMM_CAUSE_NO_SUITABLE_CELL_IN_TA    = 0x0f,
    EM_EMM_CAUSE_MSC_NOT_REACHABLE    = 0x10,
    EM_EMM_CAUSE_NW_FAILURE    = 0x11,
    EM_EMM_CAUSE_CS_NOT_AVAILABLE    = 0x12,
    EM_EMM_CAUSE_ESM_FAILURE    = 0x13,
    EM_EMM_CAUSE_MAC_FAILURE    = 0x14,
    EM_EMM_CAUSE_SYNCH_FAILURE    = 0x15,
    EM_EMM_CAUSE_CONGESTION    = 0x16,
    EM_EMM_CAUSE_UE_SEC_CAPA_MISMATCH    = 0x17,
    EM_EMM_CAUSE_SEC_MODE_REJ_UNSPECIFIED    = 0x18,
    EM_EMM_CAUSE_NOT_AUTH_FOR_CSG    = 0x19,
    EM_EMM_CAUSE_NON_EPS_AUTH_UNACCEPTABLE    = 0x1a,
    EM_EMM_CAUSE_CS_TEMP_NOT_AVAILABLE    = 0x27,
    EM_EMM_CAUSE_NO_EPS_CTXT_ACT    = 0x28,
    EM_EMM_CAUSE_SEMANTIC_INCORRECT    = 0x5f,
    EM_EMM_CAUSE_INVALID_MANDATORY_INFO    = 0x60,
    EM_EMM_CAUSE_MSG_TYPE_NOT_EXIST    = 0x61,
    EM_EMM_CAUSE_MSG_TYPE_NOT_COMPATIBLE    = 0x62,
    EM_EMM_CAUSE_IE_NOT_EXIST    = 0x63,
    EM_EMM_CAUSE_CONDITIONAL_IE_ERROR    = 0x64,
    EM_EMM_CAUSE_MESSAGE_NOT_COMPATIBLE    = 0x65,
    EM_EMM_CAUSE_PROTOCOL_ERROR    = 0x6f,

    EM_EMM_CAUSE_FORBIDDEN_PLMN, /* 0x70 */
    EM_EMM_CAUSE_NO_COVERAGE                       = 0x72,
    EM_EMM_CAUSE_SIM_REMOVED                       = 0x76,
    EM_EMM_CAUSE_SIM_INVALID_FOR_PS                = 0x78,
    EM_EMM_CAUSE_SIM_INVALID_FOR_CS,
    EM_EMM_CAUSE_SIM_INVALID_FOR_CS_AND_PS
} em_emm_cause_enum;


typedef enum
{
    EM_EMM_ATTACH_TYPE_INVALID = 0,
    EM_EMM_ATTACH_TYPE_EPS_ATTACH    = 1,
    EM_EMM_ATTACH_TYPE_COMBINED_ATTACH    = 2,
    EM_EMM_ATTACH_TYPE_EMERGENCY_ATTACH    = 6
} em_emm_attach_type_enum;

typedef enum
{
    EM_EMM_ATTACH_RESULT_EPS_ONLY_ATTACHED    = 1,
    EM_EMM_ATTACH_RESULT_COMBINED_ATTACHED
} em_emm_attach_result_enum;

typedef enum
{
    EM_EMM_TYPE_NO_ADDITIONAL_INFO = 1,
    EM_EMM_TYPE_SMS_ONLY
}em_emm_additional_update_type_enum;

typedef enum
{
    EM_EMM_RESULT_NO_ADDITIONAL_INFO = 0,
    EM_EMM_RESULT_CSFB_NOT_PREFERRED = 1,
    EM_EMM_RESULT_SMS_ONLY           = 2
}em_emm_additional_update_result_enum;

typedef enum
{
    EM_EMM_UPDATE_TYPE_TAU    = 0,
    EM_EMM_UPDATE_TYPE_COMBINED_TAU,
    EM_EMM_UPDATE_TYPE_COMBINED_TAU_IMSI_ATTACH,
    EM_EMM_UPDATE_TYPE_PERIODIC_TAU,
    EM_EMM_UPDATE_TYPE_INVALID
} em_emm_update_type_enum;

typedef enum
{
    EM_EMM_UPDATE_RESULT_TA_UPDATED = 0,
    EM_EMM_UPDATE_RESULT_COMBINED_UPDATED = 1,
    EM_EMM_UPDATE_RESULT_TA_UPDATED_ISR_ACTIVATED = 4,
    EM_EMM_UPDATE_RESULT_COMBINED_UPDATED_ISR_ACTIVATED = 5,
    EM_EMM_UPDATE_RESULT_INVALID
} em_emm_update_result_enum;

typedef enum
{
    EM_EMM_USER_DETACH_EPS_DETACH  = 1,
    EM_EMM_USER_DETACH_IMSI_DETACH ,
    EM_EMM_USER_DETACH_COMBINED_EPS_IMSI_DETACH
}em_emm_user_detach_type_enum;

typedef enum
{
    EM_EMM_NW_DETACH_TYPE_RE_ATTACH_REQUIRED = 1,
    EM_EMM_NW_DETACH_TYPE_RE_ATTACH_NOT_REQUIRED,
    EM_EMM_NW_DETACH_TYPE_IMSI_DETACH    
}em_emm_nw_detach_type_enum;

typedef enum
{
    EM_EMM_IMS_VOICE_OVER_PS_SESSION_IN_S1_MODE_NOT_SUPPORT = 0,
    EM_EMM_IMS_VOICE_OVER_PS_SESSION_IN_S1_MODE_SUPPORT
}em_emm_ims_service_ind_enum;

typedef enum
{
    EM_EMM_EMERGENCY_BEARER_SERVICE_IN_S1_MODE_NOT_SUPPORT = 0,
    EM_EMM_EMERGENCY_BEARER_SERVICE_IN_S1_MODE_SUPPORT
}em_emm_emergency_service_ind_enum;

typedef enum
{
    EM_EMM_ATTACH_NEEDED = 0,
    EM_EMM_ATTACH_REQUEST,
    EM_EMM_ATTACH_COMPLETE,
    EM_EMM_ATTACH_SUCCESS,
    EM_EMM_23G_ATTACH_SUCCESS
}em_emm_attach_status;

typedef enum
{
    EM_EMM_TAU_ONGOING_BEFORE_TAU_REQ = 0,
    EM_EMM_TAU_REQUEST,
    EM_EMM_TAU_COMPLETE,
    EM_EMM_TAU_SUCCESS,
    EM_EMM_TAU_FAIL,
    EM_EMM_TAU_NO_TAU_EVER
}em_emm_tau_status;

typedef struct
{
    plmn_struct plmn_id;
    kal_uint8 lac[2];
}em_emm_lai_struct;

typedef struct
{
    em_sr_type_enum              service_request_type;
    em_sr_cause_enum             service_request_cause;
    em_mo_csfb_cause_enum        mo_csfb_cause;
    em_mt_csfb_paging_id_enum    mt_csfb_paging_id;

}l4c_em_emm_call_para_struct;

typedef struct
{
    em_emm_ecm_status_enum ecm_status;

}l4c_em_emm_conn_para_struct;


typedef struct
{
    em_emm_attach_type_enum                 eps_attach_type;
    em_emm_additional_update_type_enum      attach_additional_update_type;
    em_emm_attach_result_enum               eps_attach_result;
    em_emm_additional_update_result_enum    attach_additional_update_result;
    em_emm_cause_enum                       attach_emm_cause;
    kal_uint32                              attach_attempt_count;
    em_emm_attach_status                    attach_status;

    em_emm_update_type_enum                 tau_req_update_type;
    em_emm_additional_update_type_enum      tau_additional_update_type;
    em_emm_update_result_enum               tau_update_result;
    em_emm_additional_update_result_enum    tau_additional_update_result;
    em_emm_cause_enum                       tau_emm_cause;
    kal_uint32                              tau_attempt_count;
    em_emm_tau_status                       tau_status;

    em_emm_user_detach_type_enum            user_detach_type;
    em_emm_nw_detach_type_enum              nw_detach_type;
    em_emm_cause_enum                       nw_detach_emm_cause;
    kal_uint32                              detach_attempt_count;

    em_emm_ims_service_ind_enum             ims_service_ind;
    em_emm_emergency_service_ind_enum       emergency_service_ind;
    
    em_emm_lai_struct                       lai;
}l4c_em_emm_reg_para_struct;

typedef struct
{
    plmn_struct selected_plmn;
    kal_uint16        tac;
    em_csg_access_mode_enum  csg_access_mode;
    kal_uint32        csg_id;
    em_lte_duplex_type_enum  duplex_type;
    
}l4c_em_emm_plmnsel_para_struct;

typedef struct
{
    em_emm_update_status_enum update_status;
    em_emm_sim_status_enum cs_sim_status;
    em_emm_sim_status_enum ps_sim_status;
    em_emm_guti_struct guti;
    
}l4c_em_emm_usimsrv_para_struct;

typedef struct
{
    em_emm_tin_enum tin;
}l4c_em_emm_nvmsrv_para_struct;

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum 							em_info;
    l4c_em_emm_call_para_struct             emm_call_para;
    l4c_em_emm_conn_para_struct             emm_conn_para;    
    l4c_em_emm_reg_para_struct              emm_reg_para;
    l4c_em_emm_plmnsel_para_struct          emm_plmnsel_para;
    l4c_em_emm_usimsrv_para_struct          emm_usimsrv_para;
    l4c_em_emm_nvmsrv_para_struct           emm_nvmsrv_para;    
} em_emm_l4c_emm_info_ind_struct;

typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum    em_info;
}em_emm_l4c_lai_change_info_ind_struct;

/********************* end of EMM definition ****************************/


/********************* begin of ESM definition ****************************/

typedef enum
{
	EM_ESM_SYSTEM_STATE_ATTACH_NONE,
	EM_ESM_SYSTEM_STATE_ATTACH_INIT,
	EM_ESM_SYSTEM_STATE_ATTACH_ING,
	EM_ESM_SYSTEM_STATE_ATTACH_NORMAL,
	EM_ESM_SYSTEM_STATE_ATTACH_EMERGENCY,
	EM_ESM_SYSTEM_STATE_RAT_CHANGE,
	EM_ESM_SYSTEM_STATE_RAT_2G3G
} l4c_em_esm_system_state_enum;

typedef enum
{
	EM_ESM_RAT_STATE_INACTIVE,
	EM_ESM_RAT_STATE_4G,
	EM_ESM_RAT_STATE_4G23_PENDING,
	EM_ESM_RAT_STATE_4G23_CONTEXT_MAP,
	EM_ESM_RAT_STATE_23G,
	EM_ESM_RAT_STATE_23G4_PENDING,
	EM_ESM_RAT_STATE_23G4_CONTEXT_MAP
} l4c_em_esm_rat_state_enum;

typedef struct
{
	l4c_em_esm_system_state_enum 	em_esm_sys_state;
	l4c_em_esm_rat_state_enum 		em_esm_rat_state;
	
	kal_uint8											em_esm_active_pt_num;
	kal_uint8											em_esm_active_epsb_num;
	kal_uint8											em_esm_active_drb_num;

}	l4c_em_esm_status_struct;

typedef enum
{
	EM_ESM_PT_REQ_REASON_NULL,
	EM_ESM_PT_REQ_REASON_REGISTER,
	EM_ESM_PT_REQ_REASON_ADD_PDN_CONN,
	EM_ESM_PT_REQ_REASON_ALLOC_BEARER_RSC,
	EM_ESM_PT_REQ_REASON_MOD_BEARER_RSC,
	EM_ESM_PT_REQ_REASON_DEACT_DED_BEARER,
	EM_ESM_PT_REQ_REASON_RMV_PDN_CONN
} l4c_em_esm_pt_req_reason_enum;

typedef enum
{
	EM_ESM_PT_STATE_TERM,
	EM_ESM_PT_STATE_INACTIVE,
	EM_ESM_PT_STATE_WAIT_MM_RES,
	EM_ESM_PT_STATE_PENDING,
	EM_ESM_PT_STATE_WAIT_RESEND,
	EM_ESM_PT_STATE_COMPLETE,
	EM_ESM_PT_STATE_RESERVED,
	EM_ESM_PT_STATE_WAIT_TERM
} l4c_em_esm_pt_state_enum;


typedef struct
{
	kal_bool													is_active;
	kal_uint8													pti;
	
	l4c_em_esm_pt_req_reason_enum			pt_req_reason;
	l4c_em_esm_pt_state_enum					pt_state;

  kal_uint8													cid;
  kal_uint8													ebi;

} l4c_em_esm_pt_struct;

typedef enum
{
		EM_ESM_EPSBC_TYPE_INVALID,
		EM_ESM_EPSBC_TYPE_DEFAULT_EPSB,
		EM_ESM_EPSBC_TYPE_DEDICATED_EPSB
} l4c_em_esm_epsbc_bearer_type_enum;


#define EM_MIN_APN_LEN 1
#define EM_MAX_APN_LEN 100

typedef struct
{
	kal_uint8			length;
	kal_uint8			data[EM_MAX_APN_LEN];

} em_apn_struct;

typedef struct
{
	kal_bool														is_active;
	kal_uint8														ebi;
	l4c_em_esm_epsbc_bearer_type_enum		bearer_type;
	kal_bool														is_emergency_bearer;
	
	kal_uint8														linked_ebi;
	kal_uint8														qci;
	
	ip_addr_struct											ip_addr;
	em_apn_struct												apn;

} l4c_em_esm_epsbc_struct;

#define EM_L4C_ESM_MAX_PT_NUM					10
#define EM_L4C_ESM_MAX_EPSB_NUM				11

typedef struct
{
	LOCAL_PARA_HDR
	em_info_enum 									em_info;
	
	l4c_em_esm_status_struct			esm_status;
	l4c_em_esm_pt_struct					esm_pt[EM_L4C_ESM_MAX_PT_NUM];
	l4c_em_esm_epsbc_struct				esm_epsbc[EM_L4C_ESM_MAX_EPSB_NUM];
} em_esm_l4c_esm_info_ind_struct;


/********************* end of ESM definition ****************************/

typedef struct
{
    kal_uint8 group_id;                  /* Group ID */
    unsigned char group_name[MAX_LEN_OF_NW_GROUP_NAME];
    
    module_type  mod_id;                 /* Mod ID */

    kal_uint32 event_id;                 /* Evnet ID */
    unsigned char event_name[MAX_LEN_OF_NW_EVENT_NAME];
    
    kal_uint16 ring_tone_id;             /* Ring Tone ID */        
} em_network_event_struct;

extern em_network_event_struct em_network_event_tbl[];

extern kal_uint32 em_get_total_mod(void);

extern kal_uint32 em_get_total_info_req(void);

extern kal_uint32 em_nw_get_total_event(void);


typedef struct
{
    LOCAL_PARA_HDR
    em_info_enum                        em_info;
    ue_mode_enum                        ue_mode;
    kal_bool                            is_sms_over_ip;
    ue_usage_setting_enum               ue_usage_setting;
    l4_voice_domain_preference_enum     eutran_vdp;
} em_rac_info_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum            em_info;

   kal_uint8               source_rat;    /* 0/1/2 -2G/3G/4G */
   kal_uint8               target_rat;
} em_ratcm_23G_rat_change_ind_struct;

typedef struct
{
   LOCAL_PARA_HDR
   em_info_enum            em_info;
  
   kal_uint8               irat_type;   /* 0x05: autonomous cell reselection procedure */
                                        /* 0x06: used by NAS to trigger search procedure */                                                                                                                                               
   kal_uint8               source_rat;  /* 0/1/2 -2G/3G/4G */
   kal_uint8               target_rat;  /* 0/1/2 -2G/3G/4G */
} em_l4c_rat_change_ind_struct;

#endif /* ~_EM_STRUCT_H */

